<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.5: http://docutils.sourceforge.net/" />
<title>The Bank part 2: More  examples of SimPy Simulation</title>
<meta name="author" content="G A Vignaux" />
<meta name="date" content="2007 October 22" />
<style type="text/css">

/*
:Author: G A Vignaux
:Contact: Tony Vignaux <Vignaux@users.sourceforge.net>
:Copyright: This stylesheet has been placed in the public domain.
:SimPy version: 1.8
:Revision: $Revision: 1.1.1.13 $ 
:Date: $Date: 2007/12/22 06:39:26 $

Stylesheet for use with Docutils.  Based on the standard but 
ensuring that computer listings are backed by grey.
*/

@import url(html4css1.css);

/* Your customizations go here.  For example: */

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;
  background-color: #eeeeee }

</style>
</head>
<body>
<div class="document" id="the-bank-part-2-more-examples-of-simpy-simulation">
<h1 class="title">The Bank part 2: More  examples of SimPy Simulation</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>G A Vignaux</td></tr>
<tr><th class="docinfo-name">Date:</th>
<td>2007 October 22</td></tr>
</tbody>
</table>
<!-- .. image:: images/sm_SimPy_Logo.png
:align: left -->
<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
<!-- 2004 October gav  079.131.13 -->
<!-- $Author: vignaux $ -->
<!-- $Revision: 1.1.1.13 $ -->
<!-- $Date: 2007/12/22 06:39:26 $ -->
<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
<!-- TO DO
add example of using SimpyTrace
Reneging due to an event
Interrupts - YES
SimEvents? -->
<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
<div class="contents topic">
<p class="topic-title first"><a id="table-of-contents" name="table-of-contents">Table Of Contents</a></p>
<ul class="auto-toc simple">
<li><a class="reference" href="#introduction" id="id2" name="id2">1&nbsp;&nbsp;&nbsp;Introduction</a></li>
<li><a class="reference" href="#priority-customers" id="id3" name="id3">2&nbsp;&nbsp;&nbsp;Priority Customers</a><ul class="auto-toc">
<li><a class="reference" href="#priority-customers-without-preemption" id="id4" name="id4">2.1&nbsp;&nbsp;&nbsp;Priority Customers without preemption</a></li>
<li><a class="reference" href="#priority-customers-with-preemption" id="id5" name="id5">2.2&nbsp;&nbsp;&nbsp;Priority Customers with preemption</a></li>
</ul>
</li>
<li><a class="reference" href="#balking-and-reneging-customers" id="id6" name="id6">3&nbsp;&nbsp;&nbsp;Balking and Reneging Customers</a><ul class="auto-toc">
<li><a class="reference" href="#balking-customers" id="id7" name="id7">3.1&nbsp;&nbsp;&nbsp;Balking Customers</a></li>
<li><a class="reference" href="#reneging-or-abandoning-customers" id="id8" name="id8">3.2&nbsp;&nbsp;&nbsp;Reneging (or abandoning) Customers</a></li>
</ul>
</li>
<li><a class="reference" href="#processes" id="id9" name="id9">4&nbsp;&nbsp;&nbsp;Processes</a><ul class="auto-toc">
<li><a class="reference" href="#interrupting-a-process" id="id10" name="id10">4.1&nbsp;&nbsp;&nbsp;Interrupting a Process.</a></li>
<li><a class="reference" href="#waituntil-the-bank-door-opens" id="id11" name="id11">4.2&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">waituntil</span></tt> the Bank door opens</a></li>
<li><a class="reference" href="#wait-for-the-doorman-to-give-a-signal-waitevent" id="id12" name="id12">4.3&nbsp;&nbsp;&nbsp;Wait for the doorman to give a signal: <tt class="docutils literal"><span class="pre">waitevent</span></tt></a></li>
</ul>
</li>
<li><a class="reference" href="#monitors" id="id13" name="id13">5&nbsp;&nbsp;&nbsp;Monitors</a><ul class="auto-toc">
<li><a class="reference" href="#plotting-a-histogram-of-monitor-results" id="id14" name="id14">5.1&nbsp;&nbsp;&nbsp;Plotting a Histogram of Monitor results</a></li>
<li><a class="reference" href="#monitoring-a-resource" id="id15" name="id15">5.2&nbsp;&nbsp;&nbsp;Monitoring a Resource</a></li>
<li><a class="reference" href="#plotting-from-resource-monitors" id="id16" name="id16">5.3&nbsp;&nbsp;&nbsp;Plotting from  Resource Monitors</a></li>
</ul>
</li>
<li><a class="reference" href="#acknowledgements" id="id17" name="id17">6&nbsp;&nbsp;&nbsp;Acknowledgements</a></li>
<li><a class="reference" href="#references" id="id18" name="id18">7&nbsp;&nbsp;&nbsp;References</a></li>
</ul>
</div>
<!-- 1  Introduction
2  Priority Customers
  2.1  Priority Customers without preemption
  2.2  Priority Customers with preemption
3  Balking and Reneging Customers
  3.1  Balking Customers
  3.2  Reneging (or abandoning) Customers
4  Processes
  4.1  Interrupting a Process.
  4.2  ``waituntil`` the Bank door opens
  4.3  Wait for the doorman to give a signal: ``waitevent``
5  Monitors
  5.1  Plotting a Histogram of Monitor results
  5.2  Monitoring a Resource
  5.3  Plotting from  Resource Monitors
6  Acknowledgements
7  References -->
<div class="section">
<h1><a class="toc-backref" href="#id2" id="introduction" name="introduction">1&nbsp;&nbsp;&nbsp;Introduction</a></h1>
<p>The first Bank tutorial, <a class="reference" href="TheBank.html">The Bank</a> , developed and explained a
series of simulation models of a simple bank using <a class="reference" href="http://simpy.sourceforge.net/">SimPy</a>. In various
models, customers arrived randomly, queued up to be served at one or
several counters, modelled using the Resource class, and, in one case,
could choose the shortest among several queues. It demonstrated the
use of the Monitor class to record delays and showed how a <tt class="docutils literal"><span class="pre">model()</span></tt>
mainline for the simulation was convenient to execute replications of
simulation runs.</p>
<p>In this extension to The Bank, I provide more examples of SimPy
facilities for which there was no room before and for some that were
developed since it was written. These facilities are generally more
complicated than those introduced before. They queueing with priority,
possibly with preemption, reneging, plotting, interrupting, waiting
until a condition occurs (<tt class="docutils literal"><span class="pre">waituntil</span></tt>) and waiting for events to
occur.</p>
<p>The programs are available without line numbers and ready to go, in
directory <tt class="docutils literal"><span class="pre">bankprograms</span></tt>. Some have trace statements for demonstration
purposes, others produce graphical output to the screen. Let me
encourage you to run them and modify them for yourself</p>
<p>SimPy itself can be obtained from: <a class="reference" href="http://simpy.sourceforge.net/">http://simpy.sourceforge.net/</a>.  It
is compatible with Python version 2.3 onwards.  The examples in this
documentation run with SimPy version 1.5 and later.</p>
<p>This tutorial should be read with the SimPy <a class="reference" href="Manual.html">Manual</a> or <a class="reference" href="cheatsheet.html">Cheatsheet</a> at
your side for reference.</p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id3" id="priority-customers" name="priority-customers">2&nbsp;&nbsp;&nbsp;Priority Customers</a></h1>
<p>In many situations there is a system of priority service. Those
customers with high priority are served first, those with low priority
must wait. In some cases, preemptive priority will even allow a
high-priority customer to interrupt the service of one with a lower
priority.</p>
<p>SimPy implements priority requests with an extra numerical priority
argument in the <tt class="docutils literal"><span class="pre">yield</span> <span class="pre">request</span></tt> command, higher values meaning
higher priority. For this to operate, the requested Resource must have
been defined with <tt class="docutils literal"><span class="pre">qType=PriorityQ</span></tt>.</p>
<div class="section">
<h2><a class="toc-backref" href="#id4" id="priority-customers-without-preemption" name="priority-customers-without-preemption">2.1&nbsp;&nbsp;&nbsp;Priority Customers without preemption</a></h2>
<p>In the first example, we modify the program with random arrivals, one
counter, and a fixed service time (like <tt class="docutils literal"><span class="pre">bank07.py</span></tt> in <a class="reference" href="TheBank.html">The Bank</a>
tutorial) to process a high priority customer. Warning: the <tt class="docutils literal"><span class="pre">seed()</span></tt>
value has been changed to <tt class="docutils literal"><span class="pre">98989</span></tt> to make the story more exciting.</p>
<p>The modifications are to the definition of the <tt class="docutils literal"><span class="pre">counter</span></tt> where we
change the <tt class="docutils literal"><span class="pre">qType</span></tt> and to the <tt class="docutils literal"><span class="pre">yield</span> <span class="pre">request</span></tt> command in the
<tt class="docutils literal"><span class="pre">visit</span></tt> PEM of the customer. We also need to provide each customer
with a priority. Since the default is <tt class="docutils literal"><span class="pre">priority=0</span></tt> this is easy for
most of them.</p>
<p>To observe the priority in action, while all other customers have the
default priority of 0, in lines 46 to 48 we create and
activate one special customer, <tt class="docutils literal"><span class="pre">Guido</span></tt>, with priority 100 who
arrives at time <tt class="docutils literal"><span class="pre">23.0</span></tt> (line 48). This is to ensure that he arrives
after <tt class="docutils literal"><span class="pre">Customer03</span></tt>.</p>
<p>The <tt class="docutils literal"><span class="pre">visit</span></tt> customer method has a new parameter, <tt class="docutils literal"><span class="pre">P=0</span></tt> (line
21) which allows us to set the customer priority.</p>
<p>In lines 38 to 38 <tt class="docutils literal"><span class="pre">counter</span></tt> is defined with <tt class="docutils literal"><span class="pre">qType=PriorityQ</span></tt> so
that we can request it with priority (line 26) using the
statement <tt class="docutils literal"><span class="pre">yield</span> <span class="pre">request,self,counter,P</span></tt></p>
<p>In line 24 we print out the number of customers waiting when each
customer arrives.</p>
<pre class="literal-block">
  1 &quot;&quot;&quot; bank20: One counter with a priority customer &quot;&quot;&quot;
  2 from SimPy.Simulation import *
  3 from random import expovariate, seed
  4 
  5 ## Model components ------------------------
  6 
  7 class Source(Process):
  8     &quot;&quot;&quot; Source generates customers randomly &quot;&quot;&quot;
  9 
 10     def generate(self,number,interval,resource):       
 11         for i in range(number):
 12             c = Customer(name = &quot;Customer%02d&quot;%(i,))
 13             activate(c,c.visit(timeInBank=12.0,
 14                                res=resource,P=0))           
 15             t = expovariate(1.0/interval)
 16             yield hold,self,t
 17 
 18 class Customer(Process):
 19     &quot;&quot;&quot; Customer arrives, is served and  leaves &quot;&quot;&quot;
 20         
 21     def visit(self,timeInBank=0,res=None,P=0):              
 22         arrive = now()       # arrival time                 
 23         Nwaiting = len(res.waitQ)
 24         print &quot;%8.3f %s: Queue is %d on arrival&quot;%(now(),self.name,Nwaiting)
 25 
 26         yield request,self,res,P                            
 27         wait = now()-arrive  # waiting time                 
 28         print &quot;%8.3f %s: Waited %6.3f&quot;%(now(),self.name,wait)
 29         yield hold,self,timeInBank
 30         yield release,self,res                              
 31 
 32         print &quot;%8.3f %s: Completed&quot;%(now(),self.name)
 33 
 34 ## Experiment data -------------------------
 35 
 36 maxTime = 400.0  # minutes                                
 37 k = Resource(name=&quot;Counter&quot;,unitName=&quot;Karen&quot;,               
 38              qType=PriorityQ)                               
 39 
 40 ## Model/Experiment ------------------------------
 41 seed(98989)
 42 initialize()
 43 s = Source('Source')
 44 activate(s,s.generate(number=5, interval=10.0,              
 45                       resource=k),at=0.0)                   
 46 guido = Customer(name=&quot;Guido     &quot;)                         
 47 activate(guido,guido.visit(timeInBank=12.0,res=k,
 48                            P=100),at=23.0)                  
 49 simulate(until=maxTime)

</pre>
<p>The resulting output is as follows. The number of customers in the
queue just as each arrives is displayed in the trace. That count does
not include any customer in service.</p>
<pre class="literal-block">
   0.000 Customer00: Queue is 0 on arrival
   0.000 Customer00: Waited  0.000
   2.166 Customer01: Queue is 0 on arrival
   5.121 Customer02: Queue is 1 on arrival
  12.000 Customer00: Completed
  12.000 Customer01: Waited  9.834
  13.347 Customer03: Queue is 1 on arrival
  23.000 Guido     : Queue is 2 on arrival
  24.000 Customer01: Completed
  24.000 Guido     : Waited  1.000
  36.000 Guido     : Completed
  36.000 Customer02: Waited 30.879
  38.156 Customer04: Queue is 1 on arrival
  48.000 Customer02: Completed
  48.000 Customer03: Waited 34.653
  60.000 Customer03: Completed
  60.000 Customer04: Waited 21.844
  72.000 Customer04: Completed

</pre>
<p>Reading carefully one can see that when <tt class="docutils literal"><span class="pre">Guido</span></tt> arrives
<tt class="docutils literal"><span class="pre">Customer00</span></tt> has been served and left at <tt class="docutils literal"><span class="pre">12.000</span></tt>), <tt class="docutils literal"><span class="pre">Customer01</span></tt>
is in service and two (customers 02 and 03) are queueing. <tt class="docutils literal"><span class="pre">Guido</span></tt>
has priority over those waiting and is served before them at
<tt class="docutils literal"><span class="pre">33.162</span></tt>. When <tt class="docutils literal"><span class="pre">Guido</span></tt> leaves at <tt class="docutils literal"><span class="pre">45.162</span></tt>, <tt class="docutils literal"><span class="pre">Customer02</span></tt> starts
service.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id5" id="priority-customers-with-preemption" name="priority-customers-with-preemption">2.2&nbsp;&nbsp;&nbsp;Priority Customers with preemption</a></h2>
<p>Now we allow <tt class="docutils literal"><span class="pre">Guido</span></tt> to have preemptive priority. He will displace
any customer in service when he arrives. That customer will resume
when <tt class="docutils literal"><span class="pre">Guido</span></tt> finishes (unless higher priority customers
intervene). It requires only a change to one line of the program,
adding the argument, <tt class="docutils literal"><span class="pre">preemptable=True</span></tt> to the <tt class="docutils literal"><span class="pre">Resource</span></tt>
statement in line 38.</p>
<pre class="literal-block">
  1 &quot;&quot;&quot; bank23: One counter with a priority customer with preemption &quot;&quot;&quot;
  2 from SimPy.Simulation import *
  3 from random import expovariate, seed
  4 
  5 ## Model components ------------------------
  6 
  7 class Source(Process):
  8     &quot;&quot;&quot; Source generates customers randomly &quot;&quot;&quot;
  9 
 10     def generate(self,number,interval,resource):       
 11         for i in range(number):
 12             c = Customer(name = &quot;Customer%02d&quot;%(i,))
 13             activate(c,c.visit(timeInBank=12.0,
 14                                res=resource,P=0))             
 15             t = expovariate(1.0/interval)
 16             yield hold,self,t
 17 
 18 class Customer(Process):
 19     &quot;&quot;&quot; Customer arrives, is served and  leaves &quot;&quot;&quot;
 20         
 21     def visit(self,timeInBank=0,res=None,P=0):                
 22         arrive = now()       # arrival time                   
 23         Nwaiting = len(res.waitQ)
 24         print &quot;%8.3f %s: Queue is %d on arrival&quot;%(now(),self.name,Nwaiting)
 25 
 26         yield request,self,res,P                              
 27         wait = now()-arrive  # waiting time                   
 28         print &quot;%8.3f %s: Waited %6.3f&quot;%(now(),self.name,wait)
 29         yield hold,self,timeInBank
 30         yield release,self,res                                
 31 
 32         print &quot;%8.3f %s: Completed&quot;%(now(),self.name)
 33 
 34 ## Experiment data -------------------------
 35 
 36 maxTime = 400.0  # minutes                                
 37 k = Resource(name=&quot;Counter&quot;,unitName=&quot;Karen&quot;,                 
 38              qType=PriorityQ, preemptable=True)               
 39 
 40 ## Model/Experiment ------------------------------
 41 seed(98989)
 42 initialize()
 43 s = Source('Source')
 44 activate(s,s.generate(number=5, interval=10.0,                
 45                       resource=k),at=0.0)                     
 46 guido = Customer(name=&quot;Guido     &quot;)                           
 47 activate(guido,guido.visit(timeInBank=12.0,res=k,
 48                            P=100),at=23.0)                    
 49 simulate(until=maxTime)

</pre>
<p>Though <tt class="docutils literal"><span class="pre">Guido</span></tt> arrives at the same time, <tt class="docutils literal"><span class="pre">23.000</span></tt>, he no longer
has to wait and immediately goes into service, displacing the
incumbent, <tt class="docutils literal"><span class="pre">Customer01</span></tt>. That customer had already completed
<tt class="docutils literal"><span class="pre">23.000-12.000</span> <span class="pre">=</span> <span class="pre">11.000</span></tt> minutes of his service. When <tt class="docutils literal"><span class="pre">Guido</span></tt>
finishes at <tt class="docutils literal"><span class="pre">35.000</span></tt>, <tt class="docutils literal"><span class="pre">Customer01</span></tt> resumes service and takes
<tt class="docutils literal"><span class="pre">36.000-35.000</span> <span class="pre">=</span> <span class="pre">1.000</span></tt> minutes to finish. His total service time
is the  same as before (<tt class="docutils literal"><span class="pre">12.000</span></tt> minutes).</p>
<pre class="literal-block">
   0.000 Customer00: Queue is 0 on arrival
   0.000 Customer00: Waited  0.000
   2.166 Customer01: Queue is 0 on arrival
   5.121 Customer02: Queue is 1 on arrival
  12.000 Customer00: Completed
  12.000 Customer01: Waited  9.834
  13.347 Customer03: Queue is 1 on arrival
  23.000 Guido     : Queue is 2 on arrival
  23.000 Guido     : Waited  0.000
  35.000 Guido     : Completed
  36.000 Customer01: Completed
  36.000 Customer02: Waited 30.879
  38.156 Customer04: Queue is 1 on arrival
  48.000 Customer02: Completed
  48.000 Customer03: Waited 34.653
  60.000 Customer03: Completed
  60.000 Customer04: Waited 21.844
  72.000 Customer04: Completed

</pre>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id6" id="balking-and-reneging-customers" name="balking-and-reneging-customers">3&nbsp;&nbsp;&nbsp;Balking and Reneging Customers</a></h1>
<p>Balking occurs when a customer refuses to join a queue if it is too
long. Reneging (or, better, abandonment) occurs if an impatient
customer gives up while still waiting and before being served.</p>
<div class="section">
<h2><a class="toc-backref" href="#id7" id="balking-customers" name="balking-customers">3.1&nbsp;&nbsp;&nbsp;Balking Customers</a></h2>
<p>Another term for a system with balking customers is one where &quot;blocked
customers&quot; are &quot;cleared&quot;, termed by engineers a BCC system. This is
very convenient analytically in queueing theory and formulae developed
using this assumption are used extensively for planning communication
systems. The easiest case is when no queueing is allowed.</p>
<p>As an example let us investigate a BCC system with a single server but
the waiting space is limited. We will estimate the rate of balking
when the maximum number in the queue is set to 1. On arrival into the
system the customer must first check to see if there is room. We will
need the number of customers in the system or waiting. We could keep a
count, incrementing when a customer joins the queue or, since we have
a Resource, use the length of the Resource's <tt class="docutils literal"><span class="pre">waitQ</span></tt>. Choosing the
latter we test (on line 25). If there is not enough room, we
balk, incrementing a Class variable <tt class="docutils literal"><span class="pre">Customer.numBalking</span></tt> at line
34 to get the total number balking during the run.</p>
<pre class="literal-block">
  1 &quot;&quot;&quot; bank24. BCC system with several counters &quot;&quot;&quot;
  2 from SimPy.Simulation import *
  3 from random import expovariate, seed
  4 
  5 ## Model components ------------------------           
  6 
  7 class Source(Process):
  8     &quot;&quot;&quot; Source generates customers randomly &quot;&quot;&quot;
  9 
 10     def generate(self,number,meanTBA,resource):          
 11         for i in range(number):
 12             c = Customer(name = &quot;Customer%02d&quot;%(i,))
 13             activate(c,c.visit(b=resource))              
 14             t = expovariate(1.0/meanTBA)                 
 15             yield hold,self,t
 16 
 17 class Customer(Process):
 18     &quot;&quot;&quot; Customer arrives, is served and leaves &quot;&quot;&quot;
 19         
 20     numBalking = 0                                       
 21 
 22     def visit(self,b):                                   
 23         arrive = now()
 24         print &quot;%8.4f %s: Here I am &quot;%(now(),self.name)
 25         if len(b.waitQ) &lt; maxInQueue:     # the test     
 26             yield request,self,b                         
 27             wait = now()-arrive
 28             print &quot;%8.4f %s: Wait %6.3f&quot;%(now(),self.name,wait)
 29             tib = expovariate(1.0/timeInBank)            
 30             yield hold,self,tib                          
 31             yield release,self,b
 32             print &quot;%8.4f %s: Finished  &quot;%(now(),self.name)
 33         else:
 34             Customer.numBalking += 1                      
 35             print &quot;%8.4f %s: BALKING   &quot;%(now(),self.name) 
 36 
 37 ## Experiment data -------------------------------       
 38 
 39 timeInBank = 12.0 # mean, minutes                        
 40 ARRint = 10.0     # mean interarrival time, minutes
 41 numServers = 1    # servers
 42 maxInSystem = 2   # customers
 43 maxInQueue = maxInSystem - numServers                    
 44 
 45 maxNumber = 8
 46 maxTime = 4000.0 # minutes                                      
 47 theseed = 12345                                          
 48 
 49 ## Model/Experiment ------------------------------
 50 
 51 seed(theseed)                                            
 52 k = Resource(capacity=numServers,
 53              name=&quot;Counter&quot;,unitName=&quot;Clerk&quot;)            
 54 
 55 initialize()
 56 s = Source('Source')
 57 activate(s, s.generate(number=maxNumber,meanTBA=ARRint, 
 58                          resource=k),at=0.0)             
 59 simulate(until=maxTime)
 60 
 61 ## Results -----------------------------------------
 62 
 63 nb = float(Customer.numBalking)
 64 print &quot;balking rate is %8.4f per minute&quot;%(nb/now())

</pre>
<p>The resulting output for a run of this program showing balking
occurring is given below:</p>
<pre class="literal-block">
  0.0000 Customer00: Here I am 
  0.0000 Customer00: Wait  0.000
  8.7558 Customer01: Here I am 
 10.6770 Customer02: Here I am 
 10.6770 Customer02: BALKING   
 22.7622 Customer03: Here I am 
 22.7622 Customer03: BALKING   
 32.7477 Customer04: Here I am 
 32.7477 Customer04: BALKING   
 49.1642 Customer05: Here I am 
 49.1642 Customer05: BALKING   
 54.8556 Customer06: Here I am 
 54.8556 Customer06: BALKING   
 55.0607 Customer00: Finished  
 55.0607 Customer01: Wait 46.305
 73.0765 Customer07: Here I am 
 80.0846 Customer01: Finished  
 80.0846 Customer07: Wait  7.008
 86.9980 Customer07: Finished  
balking rate is   0.0575 per minute

</pre>
<p>When <tt class="docutils literal"><span class="pre">Customer02</span></tt> arrives, numbers 00 is already in service and 01
is waiting. There is no room so 02 balks. By the vagaries of
exponential random numbers, 00 takes a very long time to serve (55.0607
minutes) so the first one to find room is number 07 at 73.0765.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id8" id="reneging-or-abandoning-customers" name="reneging-or-abandoning-customers">3.2&nbsp;&nbsp;&nbsp;Reneging (or abandoning) Customers</a></h2>
<p>Often in practice an impatient customer will leave the queue before
being served. SimPy can model this <em>reneging</em> behaviour using a
<em>compound yield statement</em>. In such a statement there are two
yield clauses. An example is:</p>
<pre class="literal-block">
yield (request,self,counter),(hold,self,maxWaitTime)
</pre>
<p>The first tuple of this statement is the usual <tt class="docutils literal"><span class="pre">yield</span> <span class="pre">request</span></tt>,
asking for a unit of <tt class="docutils literal"><span class="pre">counter</span></tt> Resource. The process will either get
the unit immediately or be queued by the Resource. The second tuple is
a reneging clause which has the same syntax as a <tt class="docutils literal"><span class="pre">yield</span> <span class="pre">hold</span></tt>. The
requesting process will renege if the wait exceeds <tt class="docutils literal"><span class="pre">maxWaitTime</span></tt>.</p>
<p>There is a complication, though. The requesting PEM must discover what
actually happened. Did the process get the resource or did it
renege? This involves a <em>mandatory</em> test of <tt class="docutils literal"><span class="pre">self.acquired(</span></tt><em>resource</em><tt class="docutils literal"><span class="pre">)</span></tt>. In our example, this test is in line 26.</p>
<pre class="literal-block">
  1 &quot;&quot;&quot; bank21: One counter with impatient customers &quot;&quot;&quot;
  2 from SimPy.Simulation import *
  3 from random import expovariate, seed
  4 
  5 ## Model components ------------------------
  6 
  7 class Source(Process):
  8     &quot;&quot;&quot; Source generates customers randomly &quot;&quot;&quot;
  9 
 10     def generate(self,number,interval):       
 11         for i in range(number):
 12             c = Customer(name = &quot;Customer%02d&quot;%(i,))
 13             activate(c,c.visit(timeInBank=15.0))
 14             t = expovariate(1.0/interval)
 15             yield hold,self,t
 16 
 17 class Customer(Process):
 18     &quot;&quot;&quot; Customer arrives, is served and  leaves &quot;&quot;&quot;
 19         
 20     def visit(self,timeInBank=0):       
 21         arrive = now()       # arrival time                     
 22         print &quot;%8.3f %s: Here I am     &quot;%(now(),self.name)
 23 
 24         yield (request,self,counter),(hold,self,maxWaitTime)    
 25         wait = now()-arrive  # waiting time                     
 26         if self.acquired(counter):                              
 27             print &quot;%8.3f %s: Waited %6.3f&quot;%(now(),self.name,wait)
 28             yield hold,self,timeInBank
 29             yield release,self,counter                          
 30             print &quot;%8.3f %s: Completed&quot;%(now(),self.name)
 31         else:
 32             print &quot;%8.3f %s: Waited %6.3f. I am off&quot;%(now(),self.name,wait)
 33         
 34 ## Experiment data -------------------------
 35 
 36 maxTime = 400.0  # minutes                                 
 37 maxWaitTime = 12.0 # minutes. maximum time to wait              
 38 
 39 ## Model  ----------------------------------
 40 
 41 def model():                                                    
 42     global counter                                              
 43     seed(98989)
 44     counter = Resource(name=&quot;Karen&quot;)                            
 45     initialize()
 46     source = Source('Source')
 47     activate(source,
 48              source.generate(number=5, interval=10.0),at=0.0)   
 49     simulate(until=maxTime)                                     
 50 
 51 ## Experiment  ----------------------------------
 52 
 53 model()

</pre>
<pre class="literal-block">
   0.000 Customer00: Here I am     
   0.000 Customer00: Waited  0.000
   2.166 Customer01: Here I am     
   5.121 Customer02: Here I am     
  13.347 Customer03: Here I am     
  14.166 Customer01: Waited 12.000. I am off
  15.000 Customer00: Completed
  15.000 Customer02: Waited  9.879
  25.347 Customer03: Waited 12.000. I am off
  30.000 Customer02: Completed
  38.156 Customer04: Here I am     
  38.156 Customer04: Waited  0.000
  53.156 Customer04: Completed

</pre>
<p><tt class="docutils literal"><span class="pre">Customer01</span></tt> arrives after 00 but has only 12 minutes
patience. After that time in the queue (at time 14.166) he abandons
the queue to leave 02 to take his place. 03 also abandons. 04 finds an
empty system and takes the server without having to wait.</p>
<!-- ================================================================== -->
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id9" id="processes" name="processes">4&nbsp;&nbsp;&nbsp;Processes</a></h1>
<p>In some simulations it is valuable for one SimPy Process to interrupt
another. This can only be done when the <em>victim</em> is &quot;active&quot;; that is
when it has an event scheduled for it. It must be executing a <tt class="docutils literal"><span class="pre">yield</span>
<span class="pre">hold</span></tt> statement.</p>
<p>A process waiting for a resource (after a <tt class="docutils literal"><span class="pre">yield</span> <span class="pre">request</span></tt>
statement) is passive and cannot be interrupted by another. Instead
the <tt class="docutils literal"><span class="pre">yield</span> <span class="pre">waituntil</span></tt> and <tt class="docutils literal"><span class="pre">yield</span> <span class="pre">waitevent</span></tt> facilities have been
introduced to allow processes to wait for conditions set by other
processes.</p>
<div class="section">
<h2><a class="toc-backref" href="#id10" id="interrupting-a-process" name="interrupting-a-process">4.1&nbsp;&nbsp;&nbsp;Interrupting a Process.</a></h2>
<p><tt class="docutils literal"><span class="pre">Klaus</span></tt> goes into the bank to talk to the manager. For clarity we
ignore the counters and other customers. During his conversation his
cellphone rings. When he finishes the call he continues the
conversation.</p>
<p>In this example, <tt class="docutils literal"><span class="pre">call</span></tt> is an object of the <tt class="docutils literal"><span class="pre">Call</span></tt> Process class
whose only purpose is to make the cellphone ring after a delay,
<tt class="docutils literal"><span class="pre">timeOfCall</span></tt>, an argument to its <tt class="docutils literal"><span class="pre">ring</span></tt> PEM (line 26).</p>
<p><tt class="docutils literal"><span class="pre">klaus</span></tt>, a <tt class="docutils literal"><span class="pre">Customer</span></tt>, is interrupted by the call (line 29).
He is in the middle of a <tt class="docutils literal"><span class="pre">yield</span> <span class="pre">hold</span></tt> (line 12). When he exits
from that command it is as if he went into a trance when talking to
the bank manager. He suddenly wakes up and must check (line 13)
to see whether has finished his conversation (if there was no call) or
has been interrupted.</p>
<p>If <tt class="docutils literal"><span class="pre">self.interrupted()</span></tt> is <tt class="docutils literal"><span class="pre">False</span></tt> he was not interrupted and
leaves the bank (line 21) normally. If it is <tt class="docutils literal"><span class="pre">True</span></tt>, he was
interrupted by the call, remembers how much conversation he has left
(line 14), resets the interrupt (line 15) and then deals
with the call. When he finishes (line 19) he can resume the
conversation, with, now we assume, a thoroughly irritated bank manager
(line 20).</p>
<pre class="literal-block">
  1 &quot;&quot;&quot; bank22: An interruption by a phone call &quot;&quot;&quot;          
  2 from SimPy.Simulation  import *                          
  3 
  4 ## Model components ------------------------
  5 
  6 
  7 class Customer(Process):                                 
  8     &quot;&quot;&quot; Customer arrives, looks around and leaves &quot;&quot;&quot;
  9         
 10     def visit(self,timeInBank,onphone):                  
 11         print &quot;%7.4f %s: Here I am&quot;%(now(),self.name)    
 12         yield hold,self,timeInBank                       
 13         if self.interrupted():                           
 14             timeleft = self.interruptLeft                
 15             self.interruptReset()                        
 16             print &quot;%7.4f %s: Excuse me&quot;%(now(),self.name)
 17             print &quot;%7.4f %s: Hello! I'll call back&quot;%(now(),self.name)
 18             yield hold,self,onphone                      
 19             print &quot;%7.4f %s: Sorry, where were we?&quot;%(now(),self.name)
 20             yield hold,self,timeleft                     
 21         print &quot;%7.4f %s: I must leave&quot;%(now(),self.name) 
 22    
 23 class Call(Process):                                     
 24     &quot;&quot;&quot; Cellphone call arrives and interrupts &quot;&quot;&quot; 
 25         
 26     def ring(self,klaus,timeOfCall):                     
 27         yield hold,self,timeOfCall                       
 28         print &quot;%7.4f Ringgg!&quot;%(now())                    
 29         self.interrupt(klaus)                            
 30 
 31 ## Experiment data -------------------------
 32 
 33 timeInBank = 20.0
 34 timeOfCall = 9.0
 35 onphone = 3.0
 36 maxTime = 100.0
 37 
 38 
 39 ## Model/Experiment  ----------------------------------
 40 
 41 initialize()                                             
 42 klaus = Customer(name=&quot;Klaus&quot;)                           
 43 activate(klaus,klaus.visit(timeInBank,onphone))          
 44 call = Call(klaus)                                       
 45 activate(call, call.ring(klaus,timeOfCall))              
 46 simulate(until=maxTime)                                  

</pre>
<pre class="literal-block">
 0.0000 Klaus: Here I am
 9.0000 Ringgg!
 9.0000 Klaus: Excuse me
 9.0000 Klaus: Hello! I'll call back
12.0000 Klaus: Sorry, where were we?
23.0000 Klaus: I must leave

</pre>
<p>As this has no random numbers the results are reasonably clear: the
interrupting call occurs at 9.0. It takes <tt class="docutils literal"><span class="pre">klaus</span></tt> 3 minutes to
listen to the message and he resumes the conversation with the bank
manager at 12.0. His total time of conversation is 9.0 + 11.0 = 20.0
minutes as it would have been if the interrupt had not occurred.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id11" id="waituntil-the-bank-door-opens" name="waituntil-the-bank-door-opens">4.2&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">waituntil</span></tt> the Bank door opens</a></h2>
<p>Customers arrive at random, some of them getting to the bank before
the door is opened by a doorman. They wait for the door to be opened
and then rush in and queue to be served.</p>
<p>This model uses the <tt class="docutils literal"><span class="pre">waituntil</span></tt> yield command. In the program listing
the door is initially closed (line 7) and a function to test if
it is open is defined at line 8.</p>
<p>The <tt class="docutils literal"><span class="pre">Doorman</span></tt> class is defined starting at line 11 and the single
<tt class="docutils literal"><span class="pre">doorman</span></tt> is created and activated at at lines 65 and 66. The
doorman waits for an average 10 minutes (label 16) and then
opens the door.</p>
<p>The <tt class="docutils literal"><span class="pre">Customer</span></tt> class is defined at 29 and a new customer prints out
<tt class="docutils literal"><span class="pre">Here</span> <span class="pre">I</span> <span class="pre">am</span></tt> on arrival. If the door is still closed, he adds <tt class="docutils literal"><span class="pre">but</span>
<span class="pre">the</span> <span class="pre">door</span> <span class="pre">is</span> <span class="pre">shut</span></tt> and settles down to wait (line 40), using the
<tt class="docutils literal"><span class="pre">yield</span> <span class="pre">waituntil</span></tt> command. When the door is opened by the doorman the
<tt class="docutils literal"><span class="pre">dooropen</span></tt> state is changed and the customer (and all others waiting
for the door) proceed. A customer arriving when the door is open will
not be delayed.</p>
<pre class="literal-block">
  1 &quot;&quot;&quot;bank14: *waituntil* the Bank door opens&quot;&quot;&quot;
  2 from SimPy.Simulation import *
  3 from random import expovariate,seed
  4 
  5 ## Model components ------------------------
  6 
  7 door = 'Shut'                                                 
  8 def dooropen():                                               
  9     return door=='Open'
 10 
 11 class Doorman(Process):                                       
 12     &quot;&quot;&quot; Doorman opens the door&quot;&quot;&quot;
 13     def openthedoor(self):
 14         &quot;&quot;&quot; He will open the door when he arrives&quot;&quot;&quot;
 15         global door
 16         yield hold,self,expovariate(1.0/10.0)                 
 17         door = 'Open'                                           
 18         print &quot;%7.4f Doorman: Ladies and &quot;\
 19               &quot;Gentlemen! You may all enter.&quot;%(now(),)
 20 
 21 class Source(Process):                                        
 22     &quot;&quot;&quot; Source generates customers randomly&quot;&quot;&quot;
 23     def generate(self,number,rate):       
 24         for i in range(number):
 25             c = Customer(name = &quot;Customer%02d&quot;%(i,))
 26             activate(c,c.visit(timeInBank=12.0))
 27             yield hold,self,expovariate(rate)
 28 
 29 class Customer(Process):                                      
 30     &quot;&quot;&quot; Customer arrives, is served and leaves &quot;&quot;&quot;
 31     def visit(self,timeInBank=10):       
 32         arrive = now()
 33 
 34         if dooropen():
 35             msg = ' and the door is open.'         
 36         else:
 37             msg = ' but the door is shut.'
 38         print &quot;%7.4f %s: Here I am%s&quot;%(now(),self.name,msg)
 39 
 40         yield waituntil,self,dooropen                         
 41 
 42         print &quot;%7.4f %s: I can  go in!&quot;%(now(),self.name)     
 43         wait = now()-arrive
 44         print &quot;%7.4f %s: Waited %6.3f&quot;%(now(),self.name,wait)
 45 
 46         yield request,self,counter
 47         tib = expovariate(1.0/timeInBank)
 48         yield hold,self,tib
 49         yield release,self,counter
 50 
 51         print &quot;%7.4f %s: Finished    &quot;%(now(),self.name)
 52 
 53 ## Experiment data -------------------------
 54 
 55 maxTime = 2000.0   # minutes                                     
 56 counter = Resource(1,name=&quot;Clerk&quot;)
 57 
 58 ## Model  ----------------------------------
 59 
 60 def model(SEED=393939):
 61     seed(SEED)
 62 
 63     initialize()
 64     door = 'Shut'
 65     doorman=Doorman()                                          
 66     activate(doorman,doorman.openthedoor())                    
 67     source = Source()                                                         
 68     activate(source,
 69              source.generate(number=5,rate=0.1),at=0.0)    
 70     simulate(until=400.0)
 71 
 72 ## Experiment  ----------------------------------
 73 
 74 model()

</pre>
<p>An output run for this programs shows how the first three customers
have to wait until the door is opened.</p>
<pre class="literal-block">
 0.0000 Customer00: Here I am but the door is shut.
 5.6941 Customer01: Here I am but the door is shut.
15.8155 Customer02: Here I am but the door is shut.
22.2064 Doorman: Ladies and Gentlemen! You may all enter.
22.2064 Customer00: I can  go in!
22.2064 Customer00: Waited 22.206
22.2064 Customer01: I can  go in!
22.2064 Customer01: Waited 16.512
22.2064 Customer02: I can  go in!
22.2064 Customer02: Waited  6.391
22.4603 Customer03: Here I am and the door is open.
22.4603 Customer03: I can  go in!
22.4603 Customer03: Waited  0.000
24.8884 Customer00: Finished    
30.8017 Customer04: Here I am and the door is open.
30.8017 Customer04: I can  go in!
30.8017 Customer04: Waited  0.000
57.5367 Customer01: Finished    
58.6695 Customer02: Finished    
91.0096 Customer03: Finished    
93.5228 Customer04: Finished    

</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id12" id="wait-for-the-doorman-to-give-a-signal-waitevent" name="wait-for-the-doorman-to-give-a-signal-waitevent">4.3&nbsp;&nbsp;&nbsp;Wait for the doorman to give a signal: <tt class="docutils literal"><span class="pre">waitevent</span></tt></a></h2>
<p>Customers arrive at random, some of them getting to the bank before
the door is open. This is controlled by an automatic machine called
the doorman which opens the door only at intervals of 30 minutes (it
is a very secure bank). The customers wait for the door to be opened
and all those waiting enter and proceed to the counter. The door is
closed behind them.</p>
<p>This model uses the <tt class="docutils literal"><span class="pre">yield</span> <span class="pre">waitevent</span></tt> command which requires a
<tt class="docutils literal"><span class="pre">SimEvent</span></tt> to be defined (line 7).  The <tt class="docutils literal"><span class="pre">Doorman</span></tt> class is defined
at line 8 and the <tt class="docutils literal"><span class="pre">doorman</span></tt> is created and activated at at labels
61 and 62. The doorman waits for a fixed time (label
13) and then tells the customers that the door is open. This is
achieved on line 14 by signalling the <tt class="docutils literal"><span class="pre">dooropen</span></tt> event.</p>
<p>The <tt class="docutils literal"><span class="pre">Customer</span></tt> class is defined at 25 and in its PEM, when a
customer arrives, he prints out <tt class="docutils literal"><span class="pre">Here</span> <span class="pre">I</span> <span class="pre">am</span></tt>. If the door is still
closed, he adds <cite>&quot;but the door is shut`</cite> and settles down to wait for
the door to be opened using the <tt class="docutils literal"><span class="pre">yield</span> <span class="pre">waitevent</span></tt> command (line
35). When the door is opened by the doorman (that is, he sends
the <tt class="docutils literal"><span class="pre">dooropen.signal()</span></tt> the customer and any others waiting may
proceed.</p>
<pre class="literal-block">
  1 &quot;&quot;&quot; bank13: Wait for the doorman to give a signal: *waitevent*&quot;&quot;&quot;
  2 from SimPy.Simulation import *
  3 from random import *
  4 
  5 ## Model components ------------------------
  6 
  7 dooropen=SimEvent(&quot;Door Open&quot;)                                
  8 class Doorman(Process):                                       
  9     &quot;&quot;&quot; Doorman opens the door&quot;&quot;&quot;
 10     def openthedoor(self):
 11         &quot;&quot;&quot; He will opens the door at fixed intervals&quot;&quot;&quot;
 12         for i in range(5):
 13             yield hold,self, 30.0                              
 14             dooropen.signal()                                     
 15             print &quot;%7.4f You may enter&quot;%(now(),)
 16 
 17 class Source(Process):                                        
 18     &quot;&quot;&quot; Source generates customers randomly&quot;&quot;&quot;
 19     def generate(self,number,rate):       
 20         for i in range(number):
 21             c = Customer(name = &quot;Customer%02d&quot;%(i,))
 22             activate(c,c.visit(timeInBank=12.0))
 23             yield hold,self,expovariate(rate)
 24 
 25 class Customer(Process):                                      
 26     &quot;&quot;&quot; Customer arrives, is served and leaves &quot;&quot;&quot;
 27     def visit(self,timeInBank=10):       
 28         arrive = now()
 29 
 30         if dooropen.occurred:
 31             msg = '.'                                         
 32         else:
 33             msg = ' but the door is shut.'
 34         print &quot;%7.4f %s: Here I am%s&quot;%(now(),self.name,msg)
 35         yield waitevent,self,dooropen                         
 36 
 37         print &quot;%7.4f %s: The door is open!&quot;%(now(),self.name)
 38 
 39         wait = now()-arrive
 40         print &quot;%7.4f %s: Waited %6.3f&quot;%(now(),self.name,wait)
 41 
 42         yield request,self,counter
 43         tib = expovariate(1.0/timeInBank)
 44         yield hold,self,tib
 45         yield release,self,counter
 46 
 47         print &quot;%7.4f %s: Finished    &quot;%(now(),self.name)
 48 
 49 ## Experiment data -------------------------
 50 
 51 maxTime = 400.0  # minutes                                    
 52 
 53 counter = Resource(1,name=&quot;Clerk&quot;)
 54 
 55 ## Model  ----------------------------------
 56 
 57 def model(SEED=393939):
 58     seed(SEED)
 59 
 60     initialize()
 61     doorman = Doorman()                                          
 62     activate(doorman,doorman.openthedoor())                    
 63     source = Source()                                                        
 64     activate(source,
 65              source.generate(number=5,rate=0.1),at=0.0)
 66     simulate(until=maxTime)
 67 
 68 
 69 ## Experiment  ----------------------------------
 70 
 71 model()

</pre>
<p>An output run for this programs shows how the first three customers
have to wait until the door is opened.</p>
<pre class="literal-block">
 0.0000 Customer00: Here I am but the door is shut.
22.2064 Customer01: Here I am but the door is shut.
27.9005 Customer02: Here I am but the door is shut.
30.0000 You may enter
30.0000 Customer02: The door is open!
30.0000 Customer02: Waited  2.099
30.0000 Customer01: The door is open!
30.0000 Customer01: Waited  7.794
30.0000 Customer00: The door is open!
30.0000 Customer00: Waited 30.000
37.9738 Customer02: Finished    
38.0219 Customer03: Here I am but the door is shut.
40.6558 Customer01: Finished    
46.3632 Customer04: Here I am but the door is shut.
60.0000 You may enter
60.0000 Customer04: The door is open!
60.0000 Customer04: Waited 13.637
60.0000 Customer03: The door is open!
60.0000 Customer03: Waited 21.978
73.3042 Customer00: Finished    
74.4369 Customer04: Finished    
90.0000 You may enter
106.7770 Customer03: Finished    
120.0000 You may enter
150.0000 You may enter

</pre>
<!-- ================================================================== -->
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id13" id="monitors" name="monitors">5&nbsp;&nbsp;&nbsp;Monitors</a></h1>
<p>Monitors (and Tallyies) are used to track and record values in a
simulation. They store a list of [time,value] pairs, one pair being
added whenever the <tt class="docutils literal"><span class="pre">observe</span></tt> method is called.  A particularly
useful characteristic is that they continue to exist after the
simulation has been completed. Thus further analysis of the results
can be carried out.</p>
<p>Monitors have a set of simple statistical methods such as <tt class="docutils literal"><span class="pre">mean</span></tt> and
<tt class="docutils literal"><span class="pre">var</span></tt> to calculate the average and variance of the observed values
-- useful in estimating the mean delay, for example.</p>
<p>They also have the <tt class="docutils literal"><span class="pre">timeAverage</span></tt> method that calculates the
time-weighted average of the recorded values. It determines the total
area under the time~value graph and divides by the total time. This is
useful for estimating the average number of customers in the bank, for
example.  There is an <em>important caveat</em> in using this method. To
estimate the correct time average you must certainly <tt class="docutils literal"><span class="pre">observe</span></tt> the
value (say the number of customers in the system) whenever it changes
(as well as at any other time you wish) but, and this is important,
observing the <em>new</em> value. The <em>old</em> value was recorded earlier. In
practice this means that if we wish to observe a changing value,
<tt class="docutils literal"><span class="pre">n</span></tt>, using the Monitor, <tt class="docutils literal"><span class="pre">Mon</span></tt>, we must keep to the the following
pattern:</p>
<pre class="literal-block">
n = n+1
Mon.observe(n,now())
</pre>
<p>Thus you make the change (not only increases) and <em>then</em> observe the new
value. Of course the simulation time <tt class="docutils literal"><span class="pre">now()</span></tt> has not changed between
the two statements.</p>
<div class="section">
<h2><a class="toc-backref" href="#id14" id="plotting-a-histogram-of-monitor-results" name="plotting-a-histogram-of-monitor-results">5.1&nbsp;&nbsp;&nbsp;Plotting a Histogram of Monitor results</a></h2>
<p>A Monitor can construct a histogram from its data using the
<tt class="docutils literal"><span class="pre">histogram</span></tt> method. In this model we monitor the time in the system
for the customers. This is calculated for each customer in line
29, using the arrival time saved in line 19. We create the
Monitor, <tt class="docutils literal"><span class="pre">Mon</span></tt>, at line 37 and the times are <tt class="docutils literal"><span class="pre">observed</span></tt> at line
30.</p>
<p>The histogram is constructed from the Monitor, after the simulation
has finished, at line 55. The <a class="reference" href="SimPlotManual/ManualPlotting.html">SimPy.SimPlot</a> package allows
simple plotting of results from simulations.  Here we use the SimPlot
<tt class="docutils literal"><span class="pre">plotHistogram</span></tt> method. The plotting routines appear in lines
57-61. The <tt class="docutils literal"><span class="pre">plotHistogram</span></tt> call is in line 58.</p>
<pre class="literal-block">
  1 &quot;&quot;&quot;bank17: Plotting a Histogram of Monitor results&quot;&quot;&quot;
  2 from SimPy.Simulation  import *
  3 from SimPy.SimPlot import *                                  
  4 from random import  expovariate,seed  
  5 
  6 ## Model components ------------------------
  7 
  8 class Source(Process):                                        
  9     &quot;&quot;&quot; Source generates customers randomly&quot;&quot;&quot;
 10     def generate(self,number,rate):       
 11         for i in range(number):
 12             c = Customer(name=&quot;Customer%02d&quot;%(i,))
 13             activate(c,c.visit(timeInBank=12.0))
 14             yield hold,self,expovariate(rate)
 15 
 16 class Customer(Process):                                      
 17     &quot;&quot;&quot; Customer arrives, is served and leaves &quot;&quot;&quot;
 18     def visit(self,timeInBank):       
 19         arrive = now()                                         
 20         #print &quot;%8.4f %s: Arrived     &quot;%(now(),self.name)
 21 
 22         yield request,self,counter
 23         #print &quot;%8.4f %s: Got counter &quot;%(now(),self.name)
 24         tib = expovariate(1.0/timeInBank)
 25         yield hold,self,tib
 26         yield release,self,counter
 27 
 28         #print &quot;%8.4f %s: Finished    &quot;%(now(),self.name)
 29         t = now()-arrive                                      
 30         Mon.observe(t)                                        
 31 
 32  
 33 ## Experiment data -------------------------
 34 
 35 maxTime = 400.0   # minutes                                     
 36 counter = Resource(1,name=&quot;Clerk&quot;)                           
 37 Mon = Monitor('Time in the Bank')                                
 38 N = 0
 39 
 40 ## Model  ----------------------------------
 41 
 42 def model(SEED=393939):                                       
 43     seed(SEED)
 44 
 45     initialize()
 46     source = Source()                                                         
 47     activate(source,
 48              source.generate(number=20,rate=0.1),at=0.0)    
 49     simulate(until=maxTime)                                      
 50 
 51 
 52 ## Experiment  ----------------------------------
 53 
 54 model()                                                        
 55 Histo = Mon.histogram(low=0.0,high=200.0,nbins=20)             
 56 
 57 plt = SimPlot()                                                  
 58 plt.plotHistogram(Histo,xlab='Time (min)',                       
 59                   title=&quot;Time in the Bank&quot;,
 60                   color=&quot;red&quot;,width=2)                         
 61 plt.mainloop()                                                 

</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id15" id="monitoring-a-resource" name="monitoring-a-resource">5.2&nbsp;&nbsp;&nbsp;Monitoring a Resource</a></h2>
<p>Now consider observing the number of customers waiting or executing in
a Resource. Because of the need to <tt class="docutils literal"><span class="pre">observe</span></tt> the value after the
change but at the same simulation instant, it is impossible to use the
length of the Resource's <tt class="docutils literal"><span class="pre">waitQ</span></tt> directly with a Monitor defined
outside the Resource. Instead Resources can be set up with built-in
Monitors.</p>
<p>Here is an example using a Monitored Resource. We intend to observe
the average number waiting and active in the <tt class="docutils literal"><span class="pre">counter</span></tt>
resource. <tt class="docutils literal"><span class="pre">counter</span></tt> is defined at line 32 and we have set
<tt class="docutils literal"><span class="pre">monitored=True</span></tt>. This establishes two Monitors: <tt class="docutils literal"><span class="pre">waitMon</span></tt>, to
record changes in the numbers waiting and <tt class="docutils literal"><span class="pre">actMon</span></tt> to record changes
in the numbers active in the <tt class="docutils literal"><span class="pre">counter</span></tt>. We need make no further
change to the operation of the program as monitoring is then
automatic.  No <tt class="docutils literal"><span class="pre">observe</span></tt> calls are necessary.</p>
<p>At the end of the run in the <tt class="docutils literal"><span class="pre">model</span></tt> function, we calculate the
<tt class="docutils literal"><span class="pre">timeAverage</span></tt> of both <tt class="docutils literal"><span class="pre">waitMon</span></tt> and <tt class="docutils literal"><span class="pre">actMon</span></tt> and return them
from the <tt class="docutils literal"><span class="pre">model</span></tt> call (line 45). These can then be printed at
the end of the program (line 49).</p>
<pre class="literal-block">
  1 &quot;&quot;&quot;bank15: Monitoring a Resource&quot;&quot;&quot;
  2 from SimPy.Simulation import *
  3 from random import expovariate,seed
  4 
  5 ## Model components ------------------------
  6 
  7 class Source(Process):                                        
  8     &quot;&quot;&quot; Source generates customers randomly&quot;&quot;&quot;
  9     def generate(self,number,rate):       
 10         for i in range(number):
 11             c = Customer(name = &quot;Customer%02d&quot;%(i,))
 12             activate(c,c.visit(timeInBank=12.0))
 13             yield hold,self,expovariate(rate)
 14 
 15 class Customer(Process):                                      
 16     &quot;&quot;&quot; Customer arrives, is served and leaves &quot;&quot;&quot;
 17     def visit(self,timeInBank):       
 18         arrive = now()
 19         print &quot;%8.4f %s: Arrived     &quot;%(now(),self.name)
 20 
 21         yield request,self,counter
 22         print &quot;%8.4f %s: Got counter &quot;%(now(),self.name)
 23         tib = expovariate(1.0/timeInBank)
 24         yield hold,self,tib
 25         yield release,self,counter
 26 
 27         print &quot;%8.4f %s: Finished    &quot;%(now(),self.name)
 28 
 29 ## Experiment data -------------------------
 30 
 31 maxTime = 400.0    # minutes                                     
 32 counter = Resource(1,name=&quot;Clerk&quot;,monitored=True)            
 33 
 34 ## Model  ----------------------------------
 35 
 36 def model(SEED=393939):
 37     seed(SEED)
 38 
 39     initialize()
 40     source = Source()                                                         
 41     activate(source,
 42              source.generate(number=5,rate=0.1),at=0.0)    
 43     simulate(until=maxTime)
 44 
 45     return (counter.waitMon.timeAverage(),counter.actMon.timeAverage()) 
 46 
 47 ## Experiment  ----------------------------------
 48 
 49 print 'Average waiting = %6.4f\nAverage active  = %6.4f\n'%model() 

</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id16" id="plotting-from-resource-monitors" name="plotting-from-resource-monitors">5.3&nbsp;&nbsp;&nbsp;Plotting from  Resource Monitors</a></h2>
<p>Like all Monitors, <tt class="docutils literal"><span class="pre">waitMon</span></tt> and <tt class="docutils literal"><span class="pre">actMon</span></tt> in a monitored Resource
contain information that enables us to graph the output. Alternative
plotting packages can be used; here we use the simple <tt class="docutils literal"><span class="pre">SimPy.SimPlot</span></tt>
package just to graph the number of customers waiting for the
counter. The program is a simple modification of the one that uses a
monitored Resource.</p>
<p>The SimPlot package is imported at line 3. No major changes are
made to the main part of the program except that I commented out the
print statements. The changes occur in the <tt class="docutils literal"><span class="pre">model</span></tt> routine from lines
37 to 44. The simulation now generates and processes 20
customers (line 43).  <tt class="docutils literal"><span class="pre">model</span></tt> does not return a value but the
Monitors of the <tt class="docutils literal"><span class="pre">counter</span></tt> Resource still exist when the simulation has
terminated.</p>
<p>The additional plotting actions take place in lines 50 to
53. Line 51-52 construct a step plot and graphs the
number in the waiting queue as a function of time. <tt class="docutils literal"><span class="pre">waitMon</span></tt> is
primarily a list of <em>[time,value]</em> pairs which the <tt class="docutils literal"><span class="pre">plotStep</span></tt> method
of the SimPlot object, <tt class="docutils literal"><span class="pre">plt</span></tt> uses without change. On running the
program the graph is plotted; the user has to terminate the plotting
<tt class="docutils literal"><span class="pre">mainloop</span></tt> on the screen.</p>
<pre class="literal-block">
  1 &quot;&quot;&quot;bank16: Plotting from  Resource Monitors&quot;&quot;&quot;
  2 from SimPy.Simulation import *
  3 from SimPy.SimPlot import *                                   
  4 from random import expovariate,seed
  5 
  6 ## Model components ------------------------           
  7 
  8 class Source(Process):                                        
  9     &quot;&quot;&quot; Source generates customers randomly&quot;&quot;&quot;
 10     def generate(self,number,rate):       
 11         for i in range(number):
 12             c = Customer(name = &quot;Customer%02d&quot;%(i,))
 13             activate(c,c.visit(timeInBank=12.0))
 14             yield hold,self,expovariate(rate)
 15 
 16 class Customer(Process):                                      
 17     &quot;&quot;&quot; Customer arrives, is served and leaves &quot;&quot;&quot;
 18     def visit(self,timeInBank):       
 19         arrive = now()
 20         #print &quot;%8.4f %s: Arrived     &quot;%(now(),self.name)
 21 
 22         yield request,self,counter
 23         #print &quot;%8.4f %s: Got counter &quot;%(now(),self.name)
 24         tib = expovariate(1.0/timeInBank)
 25         yield hold,self,tib
 26         yield release,self,counter
 27 
 28         #print &quot;%8.4f %s: Finished    &quot;%(now(),self.name)
 29 
 30 ## Experiment data -------------------------
 31 
 32 maxTime = 400.0   # minutes                                    
 33 counter = Resource(1,name=&quot;Clerk&quot;,monitored=True)            
 34 
 35 ## Model -----------------------------------
 36 
 37 def model(SEED=393939):                                       
 38     seed(SEED)
 39 
 40     initialize()
 41     source = Source()                                                         
 42     activate(source,
 43              source.generate(number=20,rate=0.1),at=0.0)    
 44     simulate(until=maxTime)                                    
 45 
 46 ## Experiment -----------------------------------
 47 
 48 model()                                                        
 49  
 50 plt = SimPlot()                                                  
 51 plt.plotStep(counter.waitMon,                                  
 52         color=&quot;red&quot;,width=2)                                   
 53 plt.mainloop()                                                 

</pre>
<!-- Some of the following links need changing -->
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id17" id="acknowledgements" name="acknowledgements">6&nbsp;&nbsp;&nbsp;Acknowledgements</a></h1>
<p>I thank Klaus Muller, Bob Helmbold, Mukhlis Matti and the other
developers and users of SimPy for improving this document by sending
their comments. I would be grateful for any further corrections or
suggestions. Please send them to: <em>vignaux</em> at
<em>users.sourceforge.net</em>.</p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id18" id="references" name="references">7&nbsp;&nbsp;&nbsp;References</a></h1>
<ul class="simple">
<li>Python website: <a class="reference" href="http://www.Python.org">http://www.Python.org</a></li>
<li>SimPy homepage: <a class="reference" href="http://simpy.sourceforge.net/">http://simpy.sourceforge.net/</a></li>
<li>The Bank: <a class="reference" href="TheBank.html">The Bank</a></li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision: 1.1.1.13 $</td>
</tr>
</tbody>
</table>
<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
<!-- Local Variables:
mode: rst
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
End: -->
</div>
</div>
<div class="footer">
<hr class="footer" />
<a class="reference" href="TheBank2.txt">View document source</a>.
Generated on: 2007-12-19 22:08 UTC.
Generated by <a class="reference" href="http://docutils.sourceforge.net/">Docutils</a> from <a class="reference" href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> source.

</div>
</body>
</html>
