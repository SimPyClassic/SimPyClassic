<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.5: http://docutils.sourceforge.net/" />
<title>The SimPy Manual</title>
<meta name="authors" content="Tony Vignaux &lt;Vignaux&#64;users.sourceforge.net&gt;  Klaus Muller &lt;Muller&#64;users.sourceforge.net&gt;  Bob Helmbold" />
<meta name="date" content="2008-03-12" />
<meta content="SimPy Python Simulation Language" name="description" />
<meta content="simulation python stochastic" name="keywords" />
<style type="text/css">

/*
:Author: G A Vignaux
:Contact: Tony Vignaux <Vignaux@users.sourceforge.net>
:Copyright: This stylesheet has been placed in the public domain.
:SimPy version: 1.8
:Revision: $Revision: 1.1.1.37 $ 
:Date: $Date: 2008/03/12 04:34:38 $

Stylesheet for use with Docutils.  Based on the standard but 
ensuring that computer listings are backed by grey.
*/

@import url(html4css1.css);

/* Your customizations go here.  For example: */

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;
  background-color: #eeeeee }

</style>
</head>
<body>
<div class="document" id="the-simpy-manual">
<h1 class="title">The SimPy Manual</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Authors:</th>
<td>Tony Vignaux &lt;<a class="reference" href="mailto:Vignaux&#64;users.sourceforge.net">Vignaux&#64;users.sourceforge.net</a>&gt;
<br />Klaus Muller &lt;<a class="reference" href="mailto:Muller&#64;users.sourceforge.net">Muller&#64;users.sourceforge.net</a>&gt;
<br />Bob Helmbold</td></tr>
<tr class="field"><th class="docinfo-name">SimPy version:</th><td class="field-body">1.9</td>
</tr>
<tr class="field"><th class="docinfo-name">SimPy Web-site:</th><td class="field-body"><a class="reference" href="http://simpy.sourceforge.net/">http://simpy.sourceforge.net/</a></td>
</tr>
<tr class="field"><th class="docinfo-name">SimPy wiki:</th><td class="field-body"><a class="reference" href="http://www.mcs.vuw.ac.nz/cgi-bin/wiki/SimPy">http://www.mcs.vuw.ac.nz/cgi-bin/wiki/SimPy</a></td>
</tr>
<tr class="field"><th class="docinfo-name">Python-Version:</th><td class="field-body">2.3+</td>
</tr>
<tr><th class="docinfo-name">Revision:</th>
<td>1.21</td></tr>
<tr><th class="docinfo-name">Date:</th>
<td>2008-03-12</td></tr>
</tbody>
</table>
<!-- CHANGES NEEDED:

SPELL CHECK

Add a paragraph about the standard PEM name ACTIONS, line 352 -->
<!-- REPLACEMENTS ==================== -->
<!-- ================================= -->
<div class="contents topic">
<p class="topic-title first"><a id="contents" name="contents">Contents</a></p>
<ul class="auto-toc simple">
<li><a class="reference" href="#introduction" id="id19" name="id19">1&nbsp;&nbsp;&nbsp;Introduction</a></li>
<li><a class="reference" href="#simulation-with-simpy" id="id20" name="id20">2&nbsp;&nbsp;&nbsp;Simulation with SimPy</a><ul class="auto-toc">
<li><a class="reference" href="#alternative-simpy-simulation-libraries" id="id21" name="id21">2.1&nbsp;&nbsp;&nbsp;Alternative SimPy simulation libraries</a></li>
</ul>
</li>
<li><a class="reference" href="#processes" id="id22" name="id22">3&nbsp;&nbsp;&nbsp;Processes</a><ul class="auto-toc">
<li><a class="reference" href="#defining-a-process" id="id23" name="id23">3.1&nbsp;&nbsp;&nbsp;Defining a process</a></li>
<li><a class="reference" href="#creating-a-process-object" id="id24" name="id24">3.2&nbsp;&nbsp;&nbsp;Creating a process object</a></li>
<li><a class="reference" href="#elapsing-time-in-a-process" id="id25" name="id25">3.3&nbsp;&nbsp;&nbsp;Elapsing time in a Process</a></li>
<li><a class="reference" href="#starting-and-stopping-simpy-process-objects" id="id26" name="id26">3.4&nbsp;&nbsp;&nbsp;Starting and stopping SimPy Process Objects</a></li>
<li><a class="reference" href="#asynchronous-interruptions" id="id27" name="id27">3.5&nbsp;&nbsp;&nbsp;Asynchronous interruptions</a></li>
<li><a class="reference" href="#advanced-synchronization-scheduling-capabilities" id="id28" name="id28">3.6&nbsp;&nbsp;&nbsp;Advanced synchronization/scheduling capabilities</a></li>
</ul>
</li>
<li><a class="reference" href="#resources" id="id29" name="id29">4&nbsp;&nbsp;&nbsp;Resources</a><ul class="auto-toc">
<li><a class="reference" href="#defining-a-resource-object" id="id30" name="id30">4.1&nbsp;&nbsp;&nbsp;Defining a Resource object</a></li>
<li><a class="reference" href="#requesting-and-releasing-a-unit-of-a-resource" id="id31" name="id31">4.2&nbsp;&nbsp;&nbsp;Requesting and releasing a unit of a Resource</a></li>
<li><a class="reference" href="#queue-order" id="id32" name="id32">4.3&nbsp;&nbsp;&nbsp;Queue Order</a></li>
<li><a class="reference" href="#reneging-leaving-a-queue-before-acquiring-a-resource" id="id33" name="id33">4.4&nbsp;&nbsp;&nbsp;Reneging -- leaving a queue before acquiring a resource</a></li>
<li><a class="reference" href="#recording-resource-queue-lengths" id="id34" name="id34">4.5&nbsp;&nbsp;&nbsp;Recording Resource queue lengths</a></li>
</ul>
</li>
<li><a class="reference" href="#levels" id="id35" name="id35">5&nbsp;&nbsp;&nbsp;Levels</a><ul class="auto-toc">
<li><a class="reference" href="#defining-a-level" id="id36" name="id36">5.1&nbsp;&nbsp;&nbsp;Defining a Level</a></li>
<li><a class="reference" href="#getting-amounts-from-a-level" id="id37" name="id37">5.2&nbsp;&nbsp;&nbsp;Getting amounts from a Level</a></li>
<li><a class="reference" href="#putting-amounts-into-a-level" id="id38" name="id38">5.3&nbsp;&nbsp;&nbsp;Putting amounts into  a Level</a></li>
<li><a class="reference" href="#reneging" id="id39" name="id39">5.4&nbsp;&nbsp;&nbsp;Reneging</a></li>
</ul>
</li>
<li><a class="reference" href="#stores" id="id40" name="id40">6&nbsp;&nbsp;&nbsp;Stores</a><ul class="auto-toc">
<li><a class="reference" href="#defining-a-store" id="id41" name="id41">6.1&nbsp;&nbsp;&nbsp;Defining a Store</a></li>
<li><a class="reference" href="#putting-objects-into-a-store" id="id42" name="id42">6.2&nbsp;&nbsp;&nbsp;Putting objects into a Store</a></li>
<li><a class="reference" href="#getting-objects-from-a-store" id="id43" name="id43">6.3&nbsp;&nbsp;&nbsp;Getting objects from  a Store</a></li>
<li><a class="reference" href="#using-the-get-filter-function" id="id44" name="id44">6.4&nbsp;&nbsp;&nbsp;Using the get filter function</a></li>
<li><a class="reference" href="#id16" id="id45" name="id45">6.5&nbsp;&nbsp;&nbsp;Reneging</a></li>
<li><a class="reference" href="#storing-objects-in-an-order" id="id46" name="id46">6.6&nbsp;&nbsp;&nbsp;Storing objects in an order</a></li>
<li><a class="reference" href="#master-slave-modeling-with-a-store" id="id47" name="id47">6.7&nbsp;&nbsp;&nbsp;Master/Slave modeling with a Store</a></li>
</ul>
</li>
<li><a class="reference" href="#random-number-generation" id="id48" name="id48">7&nbsp;&nbsp;&nbsp;Random Number Generation</a></li>
<li><a class="reference" href="#recording-simulation-results" id="id49" name="id49">8&nbsp;&nbsp;&nbsp;Recording Simulation Results</a><ul class="auto-toc">
<li><a class="reference" href="#defining-tallys-and-monitors" id="id50" name="id50">8.1&nbsp;&nbsp;&nbsp;Defining Tallys and Monitors</a></li>
<li><a class="reference" href="#observing-data" id="id51" name="id51">8.2&nbsp;&nbsp;&nbsp;Observing data</a></li>
<li><a class="reference" href="#data-summaries" id="id52" name="id52">8.3&nbsp;&nbsp;&nbsp;Data summaries</a></li>
<li><a class="reference" href="#special-methods-for-monitor" id="id53" name="id53">8.4&nbsp;&nbsp;&nbsp;Special methods for Monitor</a></li>
<li><a class="reference" href="#histograms" id="id54" name="id54">8.5&nbsp;&nbsp;&nbsp;Histograms</a></li>
</ul>
</li>
<li><a class="reference" href="#other-links" id="id55" name="id55">9&nbsp;&nbsp;&nbsp;Other Links</a></li>
<li><a class="reference" href="#acknowledgments" id="id56" name="id56">10&nbsp;&nbsp;&nbsp;Acknowledgments</a></li>
<li><a class="reference" href="#appendices" id="id57" name="id57">11&nbsp;&nbsp;&nbsp;Appendices</a><ul class="auto-toc">
<li><a class="reference" href="#a0-changes-from-the-previous-version-of-simpy" id="id58" name="id58">11.1&nbsp;&nbsp;&nbsp;A0. Changes from the previous  version of SimPy</a></li>
<li><a class="reference" href="#a1-simpy-error-messages" id="id59" name="id59">11.2&nbsp;&nbsp;&nbsp;A1. SimPy Error Messages</a></li>
<li><a class="reference" href="#a2-simpy-process-states" id="id60" name="id60">11.3&nbsp;&nbsp;&nbsp;A2. SimPy Process States</a></li>
<li><a class="reference" href="#a3-simplot-the-simpy-plotting-utility" id="id61" name="id61">11.4&nbsp;&nbsp;&nbsp;A3. SimPlot, The SimPy plotting utility</a></li>
<li><a class="reference" href="#a4-simgui-the-simpy-graphical-user-interface" id="id62" name="id62">11.5&nbsp;&nbsp;&nbsp;A4. SimGUI, The SimPy Graphical User Interface</a></li>
<li><a class="reference" href="#a5-simulationtrace-the-simpy-tracing-utility" id="id63" name="id63">11.6&nbsp;&nbsp;&nbsp;A5. SimulationTrace, the SimPy tracing utility</a></li>
<li><a class="reference" href="#a6-simulationstep-the-simpy-event-stepping-utility" id="id64" name="id64">11.7&nbsp;&nbsp;&nbsp;A6. SimulationStep, the SimPy event stepping utility</a></li>
<li><a class="reference" href="#a7-simulationrt-a-real-time-synchronizing-utility" id="id65" name="id65">11.8&nbsp;&nbsp;&nbsp;A7. SimulationRT, a real-time synchronizing utility</a></li>
</ul>
</li>
<li><a class="reference" href="#glossary" id="id66" name="id66">12&nbsp;&nbsp;&nbsp;Glossary</a></li>
</ul>
</div>
<!-- 1   Introduction
2   Simulation with SimPy
  2.1  Alternative SimPy simulation libraries
3   Processes
  3.1  Defining a process
  3.2  Creating a process object
  3.3  Elapsing time in a Process
    3.3.1  yield hold
  3.4  Starting and stopping SimPy Process Objects
    3.4.1  activate
    3.4.2  start
    3.4.3  passivate
    3.4.4  reactivate
    3.4.5  cancel
    3.4.6  A source fragment
  3.5  Asynchronous interruptions
    3.5.1  interrupt
    3.5.2  interrupted
    3.5.3  interruptCause
    3.5.4  interruptLeft
    3.5.5  interruptReset
  3.6  Advanced synchronization/scheduling capabilities
    3.6.1  Creating and Signalling SimEvents
      3.6.1.1  Waiting or Queueing for SimEvents
    3.6.2  yield waitevent
    3.6.3  yield queueevent
      3.6.3.1  Finding Which Processes Are Waiting/Queueing for an Event, and Which Events Fired
    3.6.4  "waituntil" synchronization - - waiting for any condition
    3.6.5  yield waituntil
4   Resources
  4.1  Defining a Resource object
  4.2  Requesting and releasing a unit of a Resource
    4.2.1  yield request
    4.2.2  yield release
  4.3  Queue Order
    4.3.1  Non-priority queueing
    4.3.2  Priority requests for a Resource unit
    4.3.3  Preemptive requests for a Resource unit
    4.3.4  Note on preemptive requests with waitQ in FIFO order
  4.4  Reneging - - leaving a queue before acquiring a resource
    4.4.1  Reneging yield request
    4.4.2  Reneging after a time limit
    4.4.3  Reneging when an event has happened
    4.4.4  Note on exiting conventions and preemptive queues
  4.5  Recording Resource queue lengths
5   Levels
  5.1  Defining a Level
  5.2  Getting amounts from a Level
  5.3  Putting amounts into  a Level
  5.4  Reneging
6   Stores
  6.1  Defining a Store
  6.2  Putting objects into a Store
  6.3  Getting objects from  a Store
  6.4  Using the get filter function
  6.5  Reneging
  6.6  Storing objects in an order
  6.7  Master/Slave modeling with a Store
7   Random Number Generation
8   Recording Simulation Results
  8.1  Defining Tallys and Monitors
  8.2  Observing data
  8.3  Data summaries
  8.4  Special methods for Monitor
  8.5  Histograms
    8.5.1  Setting up a Histogram for a Tally object
    8.5.2  Setting up a Histogram for a Monitor object
9   Other Links
10  Acknowledgments
11  Appendices
  11.1  A0. Changes from the previous  version of SimPy
  11.2  A1. SimPy Error Messages
    11.2.1  Advisory messages
    11.2.2  Fatal error messages
    11.2.3  Monitor error messages
  11.3  A2. SimPy Process States
  11.4  A3. SimPlot, The SimPy plotting utility
  11.5  A4. SimGUI, The SimPy Graphical User Interface
  11.6  A5. SimulationTrace, the SimPy tracing utility
  11.7  A6. SimulationStep, the SimPy event stepping utility
  11.8  A7. SimulationRT, a real-time synchronizing utility
12  Glossary -->
<p>This document describes SimPy version 1.9 <a class="footnote-reference" href="#id2" id="id1" name="id1">[1]</a> Changes from
version 1.8 are listed in <a class="reference" href="#a0-changes-from-the-previous-version-of-simpy">Appendix A0</a>.</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1" name="id2">[1]</a></td><td>The variable <tt class="docutils literal"><span class="pre">version</span></tt>, imported from <tt class="docutils literal"><span class="pre">SimPy.Simulation</span></tt>,
contains the revision number and date of the current version.</td></tr>
</tbody>
</table>
<div class="section">
<h1><a class="toc-backref" href="#id19" id="introduction" name="introduction">1&nbsp;&nbsp;&nbsp;Introduction</a></h1>
<p>SimPy is a Python-based discrete-event simulation system that models
active components such as messages, customers, trucks, planes by
parallel processes. It provides a number of tools for the simulation
programmer including <a class="reference" href="#processes">Processes</a> to model active entities, three kinds
of resource facilities (<a class="reference" href="#resources">Resources</a>, <a class="reference" href="#levels">Levels</a>, and <a class="reference" href="#stores">Stores</a>) and ways of
recording results by using <a class="reference" href="#defining-tallys-and-monitors">Monitors</a> and <a class="reference" href="#defining-tallys-and-monitors">Tallys</a>.</p>
<p>The basic active elements of a SimPy model are process objects (i.e.,
objects of a Process class -- see <a class="reference" href="#processes">Processes</a>) <a class="footnote-reference" href="#id4" id="id3" name="id3">[2]</a>.  These may be delayed
for fixed or random times, queued at resource facilities, and may be
interrupted by or interact in other ways with other processes and
components. For example, Automobiles, modeled as process objects, may
have to queue while waiting for a pump to become available in a model
of a gas station. One obtaining a pump it takes some time to fill
before releasing the pump.</p>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3" name="id4">[2]</a></td><td>As a general practice and for brevity we will usually refer to
both process objects and their classes as &quot;processes.&quot;  Thus,
&quot;process&quot; may refer to a Process class or to a process object,
depending on context. To avoid ambiguity or for added emphasis
we often explicitly state whether a class or an object is
intended.</td></tr>
</tbody>
</table>
<p>A SimPy script contains the declaration of one or more Process classes
and the creation of process objects from them.  Each process
object  <a class="footnote-reference" href="#id6" id="id5" name="id5">[3]</a> executes its <em>Process Execution Method</em> (referred to later as a
<a class="reference" href="#pem">PEM</a>), a method that determines its actions. Each PEM runs in parallel
with (and may interact with) the PEMs of other process objects.</p>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5" name="id6">[3]</a></td><td>We will often refer to process objects as &quot;entities&quot;. This term
is frequently used in the simulation literature. Here, though,
we restrict it to process objects and it will not be used for
any other elements in the simulation.</td></tr>
</tbody>
</table>
<p>There are three types of resource facilities (<a class="reference" href="#resources">Resources</a>, <a class="reference" href="#levels">Levels</a>, and
<a class="reference" href="#stores">Stores</a>). Each type models a congestion point where process objects
may have to queue while waiting to acquire or, in some cases to
deposit, a resource.</p>
<p><a class="reference" href="#resources">Resources</a> have several <em>resource units</em>, each of which may be used by
process objects. Extending the example above, the gas station might be
modeled as a resource with its pumps as resource units. On receiving
a request for a pump from a car, the gas station resource
automatically queues waiting cars until one becomes available. The
pump resource unit is held by the car until it is released for
possible use by another car.</p>
<p><a class="reference" href="#levels">Levels</a> model the supply and consumption of a homogeneous
undifferentiated &quot;material.&quot; The Level at any time holds an amount of
material that is fully described by a scalar (real or integer). This
can be increased or decreased by process objects. For example, a gas
(petrol) station stores gas in large storage tanks. The tanks can be
increased by Tanker deliveries and reduced by cars refuelling. A car
need not return the gas to the Level in contrast to the requirement
for Resource units.</p>
<!-- Note that though a Resource must be  released by an entity that has
finished using it, a Level resource need not be  released ever though it may
be put back if that is wanted in the model. On the other hand it
might never be released at all. It might be replenished by another entity. -->
<p><a class="reference" href="#stores">Stores</a> model the production and consumption of individual items. A
store hold a list of items.  Process objects can insert or remove
items from the list.  For example, surgical procedures (treated as
process objects) require specific lists of personnel and equipment
that may be treated as the items in a Store facility such as a
clinic or hospital. The items held in a Store can be of any Python
type. In particular they can be process objects, and this may be
exploited to facilitate modeling Master/Slave relationships.</p>
<p>In addition to the number of free units or quantities, resource
facilities all hold queues of waiting process objects which are
operated automatically by SimPy. They also operate a reneging
mechanism so that a process object can abandon the wait.</p>
<p><a class="reference" href="#defining-tallys-and-monitors">Monitors</a> and <a class="reference" href="#defining-tallys-and-monitors">Tallys</a> are used to compile statistics as a function of
time on variables such as waiting times and queue lengths. These
statistics consist of simple averages and variances, time-weighted
averages, or histograms. They can be gathered on the queues associated
with Resources, Levels and Stores. For example we may collect
data on the average number of cars waiting at a gas station and the
distribution of their waiting times. Tallys update the current
statistics as the simulation progresses, but cannot preserve complete
time-series records. Monitors can preserve complete time-series
records that may later be used for more advanced post-simulation
analyses.</p>
<p>Before attempting to use SimPy, you should be able to write Python
code. In particular, you should be able to define and use classes and
their objects. Python is free and usable on most platforms.  We do not
expound it here. You can find out more about it and download it from
the <a class="reference" href="http://www.Python.org">Python</a> web-site (<a class="reference" href="http://www.Python.org">http://www.Python.org</a>). SimPy requires <em>Python</em>
2.3 or later.</p>
<p>[Return to <a class="reference" href="#contents">Top</a> ]</p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id20" id="simulation-with-simpy" name="simulation-with-simpy">2&nbsp;&nbsp;&nbsp;Simulation with SimPy</a></h1>
<p>To use the SimPy simulation system you must import its <tt class="docutils literal"><span class="pre">Simulation</span></tt>
module (or one of the <a class="reference" href="#alternative-simpy-simulation-libraries">alternatives</a>):</p>
<blockquote>
<tt class="docutils literal"><span class="pre">from</span> <span class="pre">SimPy.Simulation</span> <span class="pre">import</span> <span class="pre">*</span></tt></blockquote>
<p>All discrete-event simulation programs automatically maintain the
current simulation time in a software clock. This cannot be changed by
the user directly.  In SimPy the current clock value is returned by the
<tt class="docutils literal"><span class="pre">now()</span></tt> function.</p>
<p>At the start of the simulation the software clock is set to 0.0.
While the simulation program runs, simulation time steps forward from
one <em>event</em> to the next. An event occurs whenever the state of the
simulated system changes. For example, an event might be the arrival
or departure of a car from the gas station.</p>
<p>The following statement initializes global simulation variables and
sets the software clock to zero. It must appear in the script before
any SimPy process objects are activated.</p>
<blockquote>
<tt class="docutils literal"><span class="pre">initialize(</span> <span class="pre">)</span></tt></blockquote>
<p>This is followed by SimPy statements creating and activating process
objects. Activation of process objects adds events to the simulation
schedule. Execution of the simulation itself starts with the following
statement:</p>
<blockquote>
<tt class="docutils literal"><span class="pre">simulate(until=</span></tt><em>endtime</em><tt class="docutils literal"><span class="pre">)</span></tt></blockquote>
<p>The simulation starts, and SimPy seeks and executes the first
scheduled event. Having executed that event, the simulation seeks and
executes the next event, and so on.</p>
<p>Typically a simulation is terminated when <em>endtime</em> is reached but it
can be  stopped at any time by the command:</p>
<blockquote>
<tt class="docutils literal"><span class="pre">stopSimulation(</span> <span class="pre">)</span></tt></blockquote>
<p><tt class="docutils literal"><span class="pre">now(</span> <span class="pre">)</span></tt> will then equal the time when this was called. The
simulation will also stop if there are no more events to execute (so
<tt class="docutils literal"><span class="pre">now()</span></tt> equals the time the last scheduled event occurred)</p>
<p>After the simulation has stopped, further statements can be executed.
<tt class="docutils literal"><span class="pre">now()</span></tt> will retain the time of stopping and data held in Monitors
will be available for display or further analysis.</p>
<p>The following fragment shows only the <em>main</em> block in a simulation
program.  (Complete, runnable examples are shown in <a class="reference" href="#example-1">Example 1</a> and
<a class="reference" href="#example-2">Example 2</a>). Here <tt class="docutils literal"><span class="pre">Message</span></tt> is a (previously defined) Process
class and <tt class="docutils literal"><span class="pre">m</span></tt> is defined as an object of that class, that is, a
particular message. Activating <tt class="docutils literal"><span class="pre">m</span></tt> has the effect of scheduling at
least one event by starting the PEM of <tt class="docutils literal"><span class="pre">m</span></tt> (here called <tt class="docutils literal"><span class="pre">go</span></tt>).
The <tt class="docutils literal"><span class="pre">simulate(until=1000.0)</span></tt> statement starts the simulation itself,
which immediately jumps to the first scheduled event. It will continue
until it runs out of events to execute or the simulation time reaches
<tt class="docutils literal"><span class="pre">1000.0</span></tt>. When the simulation stops the (previously written) <tt class="docutils literal"><span class="pre">Report</span></tt>
function is called to display the results:</p>
<pre class="literal-block">
initialize()
m = Message()
activate(m,m.go(),at=0.0)
simulate(until=1000.0)

Report()  #  report results when the simulation finishes
</pre>
<div class="section">
<h2><a class="toc-backref" href="#id21" id="alternative-simpy-simulation-libraries" name="alternative-simpy-simulation-libraries">2.1&nbsp;&nbsp;&nbsp;Alternative SimPy simulation libraries</a></h2>
<p>In addition to <em>SimPy.Simulation</em>, SimPy provides three alternative
simulation libraries which have the basic <tt class="docutils literal"><span class="pre">SimPy.Simulation</span></tt>
capabilities, plus additional facilities:</p>
<blockquote>
<ul class="simple">
<li><em>SimPy.SimulationTrace</em> for program tracing:
With <tt class="docutils literal"><span class="pre">from</span> <span class="pre">SimPy.SimulationTrace</span> <span class="pre">import</span> <span class="pre">*</span></tt>, any SimPy program automatically
generates detailed event-by-event tracing output. This makes the library
ideal for program development/testing and for teaching SimPy.</li>
<li><em>SimPy.SimulationRT</em> for real time synchronization:
<tt class="docutils literal"><span class="pre">from</span> <span class="pre">SimPy.SimulationRT</span> <span class="pre">import</span> <span class="pre">*</span></tt> facilitates synchronizing simulation
time and real (wall-clock) time. This capability can be used to implement,
e.g., interactive game applications or to demonstrate a model's execution
in real time.</li>
<li><em>SimPy.SimulationStep</em> for event-stepping through a simulation:
The import <tt class="docutils literal"><span class="pre">from</span> <span class="pre">SimPy.SimulationStep</span> <span class="pre">import</span> <span class="pre">*</span></tt> provides an API for
stepping through a simulation event by event. This can assist with
debugging models, interacting with them on an event-by-event basis,
getting event-by-event output from a model (e.g. for plotting purposes),
etc.</li>
</ul>
</blockquote>
<p>[Return to <a class="reference" href="#contents">Top</a> ]</p>
<!-- ================================================================== -->
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id22" id="processes" name="processes">3&nbsp;&nbsp;&nbsp;Processes</a></h1>
<p>The active objects for discrete-event simulation in SimPy are process
objects -- instances of some class that inherits from SimPy's Process
class.</p>
<p>For example, if we are simulating a computing network we might model
each message as an object of the class <tt class="docutils literal"><span class="pre">Message</span></tt>.  When message
objects arrive at the computing network they make transitions between
nodes, wait for service at each one, are served for some time, and
eventually leave the system. The <tt class="docutils literal"><span class="pre">Message</span></tt> class specifies all the
actions of each message in its Process Execution Method (PEM).
Individual message objects are created as the simulation runs, and
their evolutions are directed by the <tt class="docutils literal"><span class="pre">Message</span></tt> class's PEM.</p>
<div class="section">
<h2><a class="toc-backref" href="#id23" id="defining-a-process" name="defining-a-process">3.1&nbsp;&nbsp;&nbsp;Defining a process</a></h2>
<p>Each Process class inherits from SimPy's <tt class="docutils literal"><span class="pre">Process</span></tt> class. For example
the header of the definition of a new <tt class="docutils literal"><span class="pre">Message</span></tt> Process class would
be:</p>
<blockquote>
<tt class="docutils literal"><span class="pre">class</span> <span class="pre">Message(Process):</span></tt></blockquote>
<p>At least one Process Execution Method (PEM) must be defined in each
Process class <a class="footnote-reference" href="#id8" id="id7" name="id7">[4]</a>.  A PEM may have arguments in addition to the required
<tt class="docutils literal"><span class="pre">self</span></tt> argument that all methods must have. Naturally, other
methods and, in particular, an <tt class="docutils literal"><span class="pre">__init__</span></tt> method, may be defined.</p>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7" name="id8">[4]</a></td><td>More than one can be defined but only one can be executed by
any process object.</td></tr>
</tbody>
</table>
<!-- Add a paragraph about the standard PEM name ACTIONS -->
<ul id="pem">
<li><p class="first"><tt class="docutils literal"><span class="pre">A</span> <span class="pre">Process</span> <span class="pre">Execution</span> <span class="pre">Method</span> <span class="pre">(PEM)</span></tt> defines the actions that are
performed by its process objects. Each PEM must contain at least one
of the <tt class="docutils literal"><span class="pre">yield</span></tt> statements, described later. This makes it a Python
generator function so that it has resumable execution -- it can be
restarted again after the yield statement without losing its current
state.  A PEM may have any name of your choice. For example it may
be called <tt class="docutils literal"><span class="pre">execute(</span> <span class="pre">)</span></tt> or <tt class="docutils literal"><span class="pre">run(</span> <span class="pre">)</span></tt>.</p>
<p>&quot;The <tt class="docutils literal"><span class="pre">yield</span></tt> statements are simulation commands which affect an
ongoing lifecycle of Process objects. These statements control the
execution and synchronization of multiple processes. They can delay
a process, put it to sleep, request a shared resource or provide a
resource. They can add new events on the simulation event schedule,
cancel existing ones, or cause processes to wait for a state
change.&quot;</p>
<p>For example, here is a the Process Execution Method, <tt class="docutils literal"><span class="pre">go(self)</span></tt>,
for the <tt class="docutils literal"><span class="pre">Message</span></tt> class. Upon activation it prints out the current
time, the message object's identification number and the word
&quot;Starting&quot;. After a simulated delay of 100.0 time units (in the
<tt class="docutils literal"><span class="pre">yield</span> <span class="pre">hold,</span> <span class="pre">...</span></tt> statement) it announces that this message object
has &quot;Arrived&quot;:</p>
<pre class="literal-block">
def go(self):
    print now(), self.i, 'Starting'
    yield hold,self,100.0
    print now(), self.i, 'Arrived'
</pre>
<p>A process object's PEM starts execution when the object is
activated, provided the <tt class="docutils literal"><span class="pre">simulate(until=</span> <span class="pre">...)</span></tt> statement has been
executed.</p>
</li>
<li><p class="first"><strong>__init__(self, ...)</strong>, where <em>...</em> indicates method
arguments. This method initializes the process object, setting
values for some or all of its attributes.  As for any sub-class in
Python, the first line of this method must call the <tt class="docutils literal"><span class="pre">Process</span></tt> class's
<tt class="docutils literal"><span class="pre">__init__(</span> <span class="pre">)</span></tt> method in the form:</p>
<blockquote>
<p><tt class="docutils literal"><span class="pre">Process.__init__(self)</span></tt></p>
</blockquote>
<p>You can then use additional commands to initialize attributes of the
Process class's objects. You can also override the standard <tt class="docutils literal"><span class="pre">name</span></tt>
attribute of the object.</p>
<p>The <tt class="docutils literal"><span class="pre">__init__(</span> <span class="pre">)</span></tt> method is always called whenever you create a
new process object. If you do not wish to provide for any attributes
other than a <tt class="docutils literal"><span class="pre">name</span></tt>, the <tt class="docutils literal"><span class="pre">__init__</span></tt> method may be dispensed
with. An example of an <tt class="docutils literal"><span class="pre">__init__(</span> <span class="pre">)</span></tt> method is shown in the
example below.</p>
</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id24" id="creating-a-process-object" name="creating-a-process-object">3.2&nbsp;&nbsp;&nbsp;Creating a process object</a></h2>
<p>An entity (process object) is created in the usual Python manner by
calling the Class. Process classes have a single argument, <tt class="docutils literal"><span class="pre">name</span></tt>
which can be specified if no <tt class="docutils literal"><span class="pre">__init__</span></tt> method is defined. It defaults to
<tt class="docutils literal"><span class="pre">'a_process'</span></tt>. It can be over-ridden if an <tt class="docutils literal"><span class="pre">__init__</span></tt> method is defined.</p>
<p>For example to create a new <tt class="docutils literal"><span class="pre">Message</span></tt> object with a name
<tt class="docutils literal"><span class="pre">Message23</span></tt>:</p>
<blockquote>
<tt class="docutils literal"><span class="pre">m</span> <span class="pre">=</span> <span class="pre">Message(name=&quot;Message23&quot;)</span></tt></blockquote>
<hr class="docutils" />
<blockquote id="example-1">
<p><strong>Example 1</strong>: This is is a complete, runnable, SimPy script. We
declare a <tt class="docutils literal"><span class="pre">Message</span></tt> class and define an <tt class="docutils literal"><span class="pre">__init__(</span> <span class="pre">)</span></tt> method and
a PEM called <tt class="docutils literal"><span class="pre">go(</span> <span class="pre">)</span></tt>.  The <tt class="docutils literal"><span class="pre">__init__(</span> <span class="pre">)</span></tt> method provide an
instance variables of an identification number and message length.
We do not actually use the <tt class="docutils literal"><span class="pre">len</span></tt> attribute in this example.</p>
<p>Two <tt class="docutils literal"><span class="pre">messages</span></tt>, <tt class="docutils literal"><span class="pre">p1</span></tt> and <tt class="docutils literal"><span class="pre">p2</span></tt> are created. <tt class="docutils literal"><span class="pre">p1</span></tt> and <tt class="docutils literal"><span class="pre">p2</span></tt>
are activated to start at simulation times 0.0 and 6.0,
respectively. Nothing happens until the <tt class="docutils literal"><span class="pre">simulate(until=200)</span></tt>
statement. When both messages have finished (at time
6.0+100.0=106.0) there will be no more events so the simulation will
stop at that time:</p>
<pre class="literal-block">
from SimPy.Simulation import *

class Message(Process):
 &quot;&quot;&quot; a simple Process &quot;&quot;&quot;
 def __init__(self,i,len):
     Process.__init__(self,name=&quot;Message&quot;+str(i))
     self.i = i
     self.len = len

 def go(self):
     print now( ), self.i, &quot;Starting&quot;
     yield hold,self,100.0
     print now( ), self.i, &quot;Arrived&quot;

initialize( )
p1  = Message(1,203)  # new message
activate(p1,p1.go( )) # activate it
p2  = Message(2,33)
activate(p2,p2.go( ),at=6.0)
simulate(until=200)
print 'Current time is ',now( ) # will print 106.0


</pre>
<p>Running this program gives the following output:</p>
<pre class="literal-block">
0 1 Starting
6.0 2 Starting
100.0 1 Arrived
106.0 2 Arrived
Current time is  106.0
</pre>
</blockquote>
</div>
<hr class="docutils" />
<div class="section">
<h2><a class="toc-backref" href="#id25" id="elapsing-time-in-a-process" name="elapsing-time-in-a-process">3.3&nbsp;&nbsp;&nbsp;Elapsing time in a Process</a></h2>
<p>A <a class="reference" href="#pem">PEM</a> uses the <tt class="docutils literal"><span class="pre">yield</span> <span class="pre">hold</span></tt> command to temporarily delay a process
object's operations.</p>
<div class="section">
<h3><a id="yield-hold" name="yield-hold">yield hold</a></h3>
<blockquote>
<p><tt class="docutils literal"><span class="pre">yield</span> <span class="pre">hold,self,</span></tt><em>t</em></p>
<p>Causes the process object to delay <em>t</em> time units <a class="footnote-reference" href="#id10" id="id9" name="id9">[5]</a>.  After the
delay, it continues with the next statement in its PEM.  During
the <tt class="docutils literal"><span class="pre">hold</span></tt> the object's operations are suspended.</p>
</blockquote>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9" name="id10">[5]</a></td><td><p class="first">unless it is further delayed by being <a class="reference" href="#asynchronous-interruptions">interrupted</a>.</p>
<p class="last">This is used to model any elapsed time  an entity might be involved
in. For example while it is passively being provided with service.</p>
</td></tr>
</tbody>
</table>
<!-- * ``yield passivate,self`` suspends the process object's operations
  until reactivated by explicit command (which must be issued by a
  different process object). -->
<hr class="docutils" />
<blockquote id="example-2">
<p><strong>Example 2:</strong> In this example the Process Execution Method,
<tt class="docutils literal"><span class="pre">buy</span></tt>, has an extra argument, <tt class="docutils literal"><span class="pre">budget</span></tt>:</p>
<pre class="literal-block">
from SimPy.Simulation import *

class Customer(Process):
   def buy(self,budget=0):
      print 'Here I am at the shops ',self.name
      t = 5.0
      for i in range(4):
          yield hold,self,t   
            # executed 4 times at intervals of t time units
          print 'I just bought something ',self.name
          budget -= 10.00
      print   'All I have left is ', budget,\
              ' I am going home ',self.name,

initialize()

# create a customer named &quot;Evelyn&quot;,
C = Customer(name='Evelyn')

# and activate her with a budget of 100
activate(C,C.buy(budget=100),at=10.0)  
    
simulate(until=100.0)

</pre>
</blockquote>
<hr class="docutils" />
<!-- ================================================================= -->
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id26" id="starting-and-stopping-simpy-process-objects" name="starting-and-stopping-simpy-process-objects">3.4&nbsp;&nbsp;&nbsp;Starting and stopping SimPy Process Objects</a></h2>
<p>A process object is &quot;passive&quot; when first created, i.e., it has no
scheduled events. It must be <em>activated</em> to start its Process
Execution Method. To activate an instance of a Process class you can
use either the <tt class="docutils literal"><span class="pre">activate</span></tt> function or the <tt class="docutils literal"><span class="pre">start</span></tt> method of the
Process. (see the <a class="reference" href="#glossary">Glossary</a> for an explanation of the modified Backus-Naur Form (BNF)
notation used).</p>
<div class="section">
<h3><a id="activate" name="activate">activate</a></h3>
<!-- -    ``activate(``\ *p, p.pemname([args])*\ ``[,{at=`` *t* ``|delay=``\ *period*\ ``}][,prior=False])`` -->
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">activate(</span></tt><em>p, p.pemname([args])</em><tt class="docutils literal"><span class="pre">[,{at=now()|delay=0}][,prior=False])</span></tt></p>
<p>activates process object <em>p</em>, provides its Process Execution Method
<em>p.pemname( )</em> with arguments <em>args</em> and possibly assigns values to the
other optional parameters. The default is to activate at the current
time (<tt class="docutils literal"><span class="pre">at=now(</span> <span class="pre">)</span></tt>) with no delay (<tt class="docutils literal"><span class="pre">delay=0.0</span></tt>) and <tt class="docutils literal"><span class="pre">prior</span></tt> set to
<tt class="docutils literal"><span class="pre">False</span></tt>.  You may assign other values to <tt class="docutils literal"><span class="pre">at</span></tt>, <tt class="docutils literal"><span class="pre">delay</span></tt>, and <tt class="docutils literal"><span class="pre">prior</span></tt>.</p>
<p>Example: to activate a process object, <tt class="docutils literal"><span class="pre">cust</span></tt> with name
<tt class="docutils literal"><span class="pre">cust001</span></tt> at time 10.0 using a PEM called <tt class="docutils literal"><span class="pre">lifetime</span></tt>:</p>
<pre class="literal-block">
activate(cust,cust.lifetime(name='cust001'),at=10.0)
</pre>
<p>However, <tt class="docutils literal"><span class="pre">delay</span></tt> overrides <tt class="docutils literal"><span class="pre">at</span></tt>, in the sense that when a
<tt class="docutils literal"><span class="pre">delay=</span></tt><em>period</em> clause is included, then activation occurs at
<tt class="docutils literal"><span class="pre">now(</span> <span class="pre">)</span></tt> or <tt class="docutils literal"><span class="pre">now(</span> <span class="pre">)+</span></tt><em>period</em> (whichever is larger), irrespective of
what value of <em>t</em> is assigned in the <tt class="docutils literal"><span class="pre">at=</span></tt><em>t</em> clause. This is true
even when the value of <em>period</em> in the delay clause is zero, or
even negative.  So it is better and clearer to choose one (or
neither) of <tt class="docutils literal"><span class="pre">at=</span></tt><em>t</em> and <tt class="docutils literal"><span class="pre">delay=</span></tt><em>period</em>, but not both.</p>
<p>If you set <tt class="docutils literal"><span class="pre">prior=True</span></tt>, then process object <em>p</em> will be
activated <em>before</em> any others that happen to be scheduled for
activation at the same time. So, if several process objects are
scheduled for activation at the same time and all have
<tt class="docutils literal"><span class="pre">prior=True</span></tt>, then the last one scheduled will actually be the
first to be activated, the next-to-last of those scheduled, the
second to be activated, and so forth.</p>
<p>Retroactive activations that attempt to activate a process
object before the current simulation time terminate the
simulation with an error report.</p>
</li>
</ul>
</div>
<div class="section">
<h3><a id="start" name="start">start</a></h3>
<p>An alternative to <tt class="docutils literal"><span class="pre">activate()</span></tt> function is the <tt class="docutils literal"><span class="pre">start</span></tt>
method. There are a number of ways of using it:</p>
<ul>
<li><p class="first"><em>p.</em><tt class="docutils literal"><span class="pre">start(</span></tt><em>p.pemname([args])</em><tt class="docutils literal"><span class="pre">[,{at=now()|delay=0}][,prior=False])</span></tt></p>
<p>is an alternative to the <tt class="docutils literal"><span class="pre">activate</span></tt> statement. <em>p</em> is a Process
object.  The generator function, <em>pemname</em>, can have any
identifier (such as <tt class="docutils literal"><span class="pre">run</span></tt>, <tt class="docutils literal"><span class="pre">lifecycle</span></tt>, etc). It can have
parameters.</p>
<p>For example, to activate the process object <tt class="docutils literal"><span class="pre">cust</span></tt> using the PEM
with identifier, <tt class="docutils literal"><span class="pre">lifetime</span></tt> at time 10.0 we would use:</p>
<pre class="literal-block">
cust.start(cust.lifetime(name='cust001'),at=10.0)
</pre>
</li>
<li><p class="first"><em>p.</em><tt class="docutils literal"><span class="pre">start([</span></tt><em>p.</em><tt class="docutils literal"><span class="pre">ACTIONS()]</span></tt> <tt class="docutils literal"><span class="pre">[,{at=now()|delay=0}][,prior=False])</span></tt></p>
<p>if <tt class="docutils literal"><span class="pre">p</span></tt> is a Process object and the generator function is given
the <em>standard identifier</em>, <tt class="docutils literal"><span class="pre">ACTIONS</span></tt>.  <tt class="docutils literal"><span class="pre">ACTIONS</span></tt>, is
recognized as a Process Execution Method. It may <em>not</em> have
parameters. The call <em>p.</em><tt class="docutils literal"><span class="pre">ACTIONS()</span></tt> is optional.</p>
<p>For example, to activate the process object <tt class="docutils literal"><span class="pre">cust</span></tt> with the standard
PEM identifier <tt class="docutils literal"><span class="pre">ACTIONS</span></tt> at time 10.0, the following are
equivalent (and the second version is more convenient):</p>
<pre class="literal-block">
cust.start(cust.ACTIONS(), at=10.0)
cust.start(at=10.0)
</pre>
</li>
<li><p class="first">An <em>anonymous</em> instance of Process class <em>PR</em> can be created and
activated in one command using <tt class="docutils literal"><span class="pre">start</span></tt> with the standard PEM
identifier, <tt class="docutils literal"><span class="pre">ACTIONS</span></tt>.</p>
<p><em>PR.</em><tt class="docutils literal"><span class="pre">([args]).start(</span></tt> <tt class="docutils literal"><span class="pre">[,{at=now()|delay=0}][,prior=False])</span></tt></p>
<p>Here, <em>PR</em> is the identifier for the Process class and not for a
Process object as was <em>p</em>, in the statements above. The generator
method <tt class="docutils literal"><span class="pre">ACTIONS</span></tt> may <em>not</em> have parameters.</p>
<p>For example, if <tt class="docutils literal"><span class="pre">Customer</span></tt> is a SimPy Process class we can create
and activate an anonymous instance at time 10.0:</p>
<pre class="literal-block">
Customer(name='cust001').start(at=10.0)
</pre>
</li>
</ul>
<p>You can use the <tt class="docutils literal"><span class="pre">passivate</span></tt>, <tt class="docutils literal"><span class="pre">reactivate</span></tt>, or <tt class="docutils literal"><span class="pre">cancel</span></tt> commands to
control Process objects.</p>
</div>
<div class="section">
<h3><a id="passivate" name="passivate">passivate</a></h3>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">yield</span> <span class="pre">passivate,self</span></tt></p>
<p>suspends the process object itself. It becomes &quot;passive&quot;. To get
it going again another process must <tt class="docutils literal"><span class="pre">reactivate</span></tt> it.</p>
</li>
</ul>
</div>
<div class="section">
<h3><a id="reactivate" name="reactivate">reactivate</a></h3>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">reactivate(</span></tt><em>p</em><tt class="docutils literal"><span class="pre">[,{at=now()|delay=0}][,prior=False])</span></tt></p>
<p>reactivates a passive process object, <em>p</em>.  It becomes
&quot;active&quot;. The optional parameters work as for <tt class="docutils literal"><span class="pre">activate</span></tt>. A
process object cannot reactivate itself.  To temporarily suspend
itself it must use <tt class="docutils literal"><span class="pre">yield</span> <span class="pre">hold,self,t</span></tt> instead.</p>
</li>
</ul>
</div>
<div class="section">
<h3><a id="cancel" name="cancel">cancel</a></h3>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">self.cancel(</span></tt><em>p</em><tt class="docutils literal"><span class="pre">)</span></tt></p>
<p>deletes all scheduled future events for process object <em>p</em>.  A
process cannot <tt class="docutils literal"><span class="pre">cancel</span></tt> itself.  If that is required, use
<tt class="docutils literal"><span class="pre">yield</span> <span class="pre">passivate,self</span></tt> instead. Only &quot;active&quot; process objects
can be canceled.</p>
</li>
</ul>
<p>A process object is &quot;terminated&quot; after all statements in its process
execution method have been completed. If the object is still
referenced by a variable, it becomes just a data container. This can be useful for
extracting information.  Otherwise, it is automatically destroyed.</p>
<p>Even activated process objects will not start operating until the
<tt class="docutils literal"><span class="pre">simulate(until=</span></tt><em>endtime</em><tt class="docutils literal"><span class="pre">)</span></tt> statement is executed. This starts the
simulation going and it will continue until time <em>endtime</em> (unless it runs
out of events to execute or the command <tt class="docutils literal"><span class="pre">stopSimulation(</span> <span class="pre">)</span></tt> is
executed).</p>
<hr class="docutils" />
<!-- an example to illustrate yield hold, perhaps. -->
<p id="example-3"><strong>Example 3</strong> This simulates a firework with a time fuse.  We have put
in a few extra <tt class="docutils literal"><span class="pre">yield</span> <span class="pre">hold</span></tt> commands for added suspense.</p>
<pre class="literal-block">
from SimPy.Simulation import *

class Firework(Process):

  def execute(self):
      print now(), ' firework launched'
      yield hold,self, 10.0    # wait 10.0 time units
      for i in range(10):
          yield hold,self,1.0
          print now(),  ' tick'
      yield hold,self,10.0     # wait another 10.0 time units
      print now(), ' Boom!!'

initialize()
f = Firework()                  # create a Firework object, and
   # activate it (with some default parameters)
activate(f,f.execute(),at=0.0)  
simulate(until=100)

</pre>
<p>Here is the output. No formatting was attempted so it looks a bit
ragged:</p>
<pre class="literal-block">
0.0  firework launched
11.0  tick
12.0  tick
13.0  tick
14.0  tick
15.0  tick
16.0  tick
17.0  tick
18.0  tick
19.0  tick
20.0  tick
30.0  Boom!!
</pre>
</div>
<hr class="docutils" />
<div class="section">
<h3><a id="a-source-fragment" name="a-source-fragment">A source fragment</a></h3>
<!-- Perhaps move this earlier and use it as a further example of yield
hold -->
<p>One useful program pattern is the <em>source</em>. This is a process object
with a Process Execution Method (PEM) that sequentially generates and activates
other process objects -- it is a source of other process
objects. Random arrivals can be modeled using random intervals
between activations.</p>
<hr class="docutils" />
<p id="example-4"><strong>Example 4: A source</strong>.  Here a source creates and activates a series of
customers who arrive at regular intervals of 10.0 units of time. This
continues until the simulation time exceeds the specified <tt class="docutils literal"><span class="pre">finishTime</span></tt>
of 33.0.  (Of course, to model customers with random inter-arrival
times the <tt class="docutils literal"><span class="pre">yield</span> <span class="pre">hold</span></tt> statement would use a random variate, such as
<tt class="docutils literal"><span class="pre">expovariate(</span> <span class="pre">)</span></tt>, instead of the constant 10.0 inter-arrival time used
here.)  The following example assumes that the <tt class="docutils literal"><span class="pre">Customer</span></tt> class has
previously been defined with a PEM called <tt class="docutils literal"><span class="pre">run</span></tt> that does not require
any arguments:</p>
<pre class="literal-block">
class Source(Process):

    def execute(self, finish):
       while now() &lt; finish:
          c = Customer()         # create a new customer object, and
              # activate it (using default parameters)
          activate(c,c.run())
          print now(), ' customer'
          yield hold,self,10.0

initialize()
g = Source()                     # create the Source object, g,
                                 # and activate it
activate(g,g.execute(finish=33.0),at=0.0)
simulate(until=100)
</pre>
</div>
</div>
<hr class="docutils" />
<div class="section">
<h2><a class="toc-backref" href="#id27" id="asynchronous-interruptions" name="asynchronous-interruptions">3.5&nbsp;&nbsp;&nbsp;Asynchronous interruptions</a></h2>
<p>An active process object can be interrupted by another but cannot
interrupt itself.</p>
<div class="section">
<h3><a id="interrupt" name="interrupt">interrupt</a></h3>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">self.interrupt(victim)</span></tt></p>
<p>The <em>interrupter</em> process object uses its <tt class="docutils literal"><span class="pre">interrupt</span></tt> method to
interrupt the <em>victim</em> process object. The interrupt is just a
<em>signal</em>. After this statement, the <em>interrupter</em> process object
continues its PEM.</p>
<p>For the interrupt to have an immediate effect, the <em>victim</em> process
object must be <em>active</em> -- that is it must have an event scheduled
for it (that is, it is &quot;executing&quot; a <tt class="docutils literal"><span class="pre">yield</span> <span class="pre">hold</span></tt> ). If the
<em>victim</em> is not active (that is, it is either <em>passive</em> or
<em>terminated</em>) the interrupt has no effect. For example, process
objects queuing for resource facilities cannot be interrupted
because they are <em>passive</em> during their queuing phase.</p>
</li>
</ul>
<p>If interrupted, the <em>victim</em> returns from its <tt class="docutils literal"><span class="pre">yield</span> <span class="pre">hold</span></tt> statement
prematurely. It must then check to see if it has been interrupted by
calling:</p>
</div>
<div class="section">
<h3><a id="interrupted" name="interrupted">interrupted</a></h3>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">self.interrupted(</span> <span class="pre">)</span></tt></p>
<p>which returns <tt class="docutils literal"><span class="pre">True</span></tt> if it has been interrupted. The <em>victim</em> can
then either continue in the current activity or switch to an
alternative, making sure it tidies up the current state, such as
releasing any resources it owns.</p>
</li>
</ul>
</div>
<div class="section">
<h3><a id="interruptcause" name="interruptcause">interruptCause</a></h3>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">self.interruptCause</span></tt></p>
<p>when the <em>victim</em> has been interrupted, <tt class="docutils literal"><span class="pre">self.interruptCause</span></tt> is a
reference to the <em>interrupter</em> object.</p>
</li>
</ul>
</div>
<div class="section">
<h3><a id="interruptleft" name="interruptleft">interruptLeft</a></h3>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">self.interruptLeft</span></tt></p>
<p>gives the time remaining in the interrupted <tt class="docutils literal"><span class="pre">yield</span> <span class="pre">hold</span></tt>. The
interruption is reset (that is, &quot;turned off&quot;) at the <em>victim's</em>
next call to a <tt class="docutils literal"><span class="pre">yield</span> <span class="pre">hold</span></tt>.</p>
</li>
</ul>
</div>
<div class="section">
<h3><a id="interruptreset" name="interruptreset">interruptReset</a></h3>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">self.interruptReset(</span> <span class="pre">)</span></tt></p>
<p>will reset the interruption.</p>
</li>
</ul>
<p>It may be helpful to think of an interruption signal as instructing
the <em>victim</em> to determine whether it should interrupt itself. If the
<em>victim</em> determines that it should interrupt itself, it then becomes
responsible for making any necessary readjustments -- not only to
itself but also to any other simulation components that are
affected. (The <em>victim</em> must take responsibility for these
adjustments, because it is the only simulation component that &quot;knows&quot;
such details as whether or not it is interrupting itself, when, and
why.)</p>
<hr class="docutils" />
<p id="example-5"><strong>Example 5</strong>. A simulation with interrupts.  A bus is subject to
breakdowns that are modeled as interrupts caused by a <tt class="docutils literal"><span class="pre">Breakdown</span></tt>
process.  Notice that the <tt class="docutils literal"><span class="pre">yield</span> <span class="pre">hold,self,tripleft</span></tt> statement may
be interrupted, so if the <tt class="docutils literal"><span class="pre">self.interrupted()</span></tt> test returns <tt class="docutils literal"><span class="pre">True</span></tt>
a reaction to it is required. Here, in addition to delaying the bus
for repairs, the reaction includes scheduling the next breakdown. In
this example the <tt class="docutils literal"><span class="pre">Bus</span></tt> Process class does not require an
<tt class="docutils literal"><span class="pre">__init__()</span></tt> method:</p>
<pre class="literal-block">
from SimPy.Simulation import *

class Bus(Process):

  def operate(self,repairduration,triplength):    # PEM
     tripleft = triplength
        # &quot;tripleft&quot; is the driving time to finish trip
        # if there are no further breakdowns
     while tripleft &gt; 0:
        yield hold,self,tripleft      # try to finish the trip
            # if a breakdown intervenes
        if self.interrupted():
              print self.interruptCause.name, 'at %s' %now()
              tripleft=self.interruptLeft
                # update driving time to finish
                # the trip if no more breakdowns
              self.interruptReset()        # end self-interrupted state
                # update next breakdown time
              reactivate(br,delay=repairduration)
                # impose delay for repairs on self
              yield hold,self,repairduration
              print 'Bus repaired at %s' %now()
        else:   # no breakdowns intervened, so bus finished trip
              break
     print 'Bus has arrived at %s' %now()

class Breakdown(Process):
   def __init__(self,myBus):
       Process.__init__(self,name='Breakdown '+myBus.name)
       self.bus=myBus

   def breakBus(self,interval):      # Process Execution Method
       while True:
          yield hold,self,interval   # driving time between breakdowns
          if self.bus.terminated(): break
            # signal &quot;self.bus&quot; to break itself down
          self.interrupt(self.bus)

initialize()
b=Bus('Bus')                   # create a Bus object &quot;b&quot; called &quot;Bus&quot;
activate(b,b.operate(repairduration=20,triplength=1000))
    # create a Breakdown object &quot;br&quot; for bus &quot;b&quot;, and
br=Breakdown(b)
    # activate it with driving time between
    # breakdowns equal to 300
activate(br,br.breakBus(300))

simulate(until=4000)
print 'SimPy: No more events at time %s' %now()
</pre>
<p>The output from this example:</p>
<pre class="literal-block">
Breakdown Bus at 300
Bus repaired at 320
Breakdown Bus at 620
Bus repaired at 640
Breakdown Bus at 940
Bus repaired at 960
Bus has arrived at 1060
SimPy: No more events at time 1260
</pre>
<hr class="docutils" />
<p>Where interrupts can occur, the victim of interrupts must test for
interrupt occurrence after every appropriate <tt class="docutils literal"><span class="pre">yield</span> <span class="pre">hold</span></tt> and react
appropriately to it. A victim holding a resource facility when it gets
interrupted continues to hold it.</p>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id28" id="advanced-synchronization-scheduling-capabilities" name="advanced-synchronization-scheduling-capabilities">3.6&nbsp;&nbsp;&nbsp;Advanced synchronization/scheduling capabilities</a></h2>
<p>The preceding scheduling constructs all depend on specified time
values. That is, they delay processes for a specific time, or use
given time parameters when reactivating them. For a wide range of
applications this is all that is needed.</p>
<p>However, some applications either require or can profit from an
ability to activate processes that must wait for other processes to
complete. For example, models of real-time systems or operating
systems often use this kind of approach. <a class="reference" href="#event">Event</a> Signalling is
particularly helpful in such situations. Furthermore, some
applications need to activate processes when certain conditions occur,
even though when (or if) they will occur may be unknown. SimPy has a
general <a class="reference" href="#wait-until">wait until</a> to support clean implementation of this
approach.</p>
<p>This section describes how SimPy provides <a class="reference" href="#event">event</a> Signalling and <a class="reference" href="#wait-until">wait
until</a> capabilities.</p>
<span class="target" id="event"></span><!-- .. _SimEvent: -->
<div class="section">
<h3><a id="creating-and-signalling-simevents" name="creating-and-signalling-simevents">Creating and Signalling SimEvents</a></h3>
<p>As mentioned in the Introduction, for ease of expression when no
confusion can arise we often refer to both process objects and their
classes as &quot;processes&quot;, and mention their object or class status only
for added clarity or emphasis. Analogously, we will refer to objects
of SimPy's <tt class="docutils literal"><span class="pre">SimEvent</span></tt> class as &quot;SimEvents&quot; <a class="footnote-reference" href="#id12" id="id11" name="id11">[6]</a> (or, if no confusion
can arise, simply as &quot;events&quot;). However, we sometimes mention their
object or class character for clarity or emphasis.</p>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11" name="id12">[6]</a></td><td>The name SimEvent was chosen because &quot;event&quot; is already
used in Python's standard library. See Python Library Reference
section <em>7.5 threading -- Higher-level threading interface</em>, specifically
subsection 7.5.5.</td></tr>
</tbody>
</table>
<p>SimEvent objects must be created before they can be fired by a
<tt class="docutils literal"><span class="pre">signal</span></tt>. You create the SimEvent object, <tt class="docutils literal"><span class="pre">sE</span></tt>, from SimPy's
<tt class="docutils literal"><span class="pre">SimEvent</span></tt> class by a statement like the following:</p>
<blockquote>
<tt class="docutils literal"><span class="pre">sE</span> <span class="pre">=</span> <span class="pre">SimEvent(name='I</span> <span class="pre">just</span> <span class="pre">had</span> <span class="pre">a</span> <span class="pre">great</span> <span class="pre">new</span> <span class="pre">idea!')</span></tt></blockquote>
<p>A SimEvent's <tt class="docutils literal"><span class="pre">name</span></tt> attribute defaults to <tt class="docutils literal"><span class="pre">a_SimEvent</span></tt> unless you
provide your own, as shown here. Its <tt class="docutils literal"><span class="pre">occurred</span></tt> attribute,
<tt class="docutils literal"><span class="pre">sE.occurred</span></tt>, is a Boolean that defaults to <tt class="docutils literal"><span class="pre">False</span></tt>. It indicates
whether the event <tt class="docutils literal"><span class="pre">sE</span></tt> has occurred.</p>
<p>You program a SimEvent to &quot;occur&quot; or &quot;fire&quot; by &quot;signaling&quot; it like this:</p>
<blockquote>
<tt class="docutils literal"><span class="pre">sE.signal(</span></tt><em>&lt;payload parameter&gt;</em><tt class="docutils literal"><span class="pre">)</span></tt></blockquote>
<p>This &quot;signal&quot; is &quot;received&quot; by all processes that are either &quot;waiting&quot;
or &quot;queueing&quot; for this event to occur. What happens when they receive
this signal is explained in the next section. The <em>&lt;payload
parameter&gt;</em> is optional -- it defaults to <tt class="docutils literal"><span class="pre">None</span></tt>. It can be of any
Python type. Any process can retrieve it from the event's
<tt class="docutils literal"><span class="pre">signalparam</span></tt> attribute, for example by:</p>
<blockquote>
<tt class="docutils literal"><span class="pre">message</span> <span class="pre">=</span> <span class="pre">sE.signalparam</span></tt></blockquote>
<div class="section">
<h4><a id="waiting-or-queueing-for-simevents" name="waiting-or-queueing-for-simevents">Waiting or Queueing for SimEvents</a></h4>
<p>You can program a process either to &quot;wait&quot; or to &quot;queue&quot; for the
occurrence of SimEvents. The difference is that <em>all</em> processes
&quot;waiting&quot; for some event are reactivated as soon as it occurs. For
example, all firemen go into action when the alarm sounds. In
contrast, only the <em>first</em> process in the &quot;queue&quot; for some event is
reactivated when it occurs. That is, the &quot;queue&quot; is FIFO <a class="footnote-reference" href="#fifo" id="id13" name="id13">[7]</a>. An example
might be royal succession -- when the present ruler dies: &quot;The king is
dead. Long live the (new) king!&quot; (And all others in the line of
succession move up one step.)</p>
<table class="docutils footnote" frame="void" id="fifo" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a name="fifo">[7]</a></td><td><em>(<a class="fn-backref" href="#id13">1</a>, <a class="fn-backref" href="#id14">2</a>, <a class="fn-backref" href="#id15">3</a>)</em> &quot;First-in-First-Out&quot; or FCFS, &quot;First-Come-First-Served&quot;</td></tr>
</tbody>
</table>
<p>You program a process to <tt class="docutils literal"><span class="pre">wait</span></tt> for SimEvents by including in its PEM:</p>
</div>
</div>
<div class="section">
<h3><a id="yield-waitevent" name="yield-waitevent">yield waitevent</a></h3>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">yield</span> <span class="pre">waitevent,self,</span></tt><em>&lt;events part&gt;</em></p>
<p>where <em>&lt;events part&gt;</em> can be either:</p>
<ul class="simple">
<li>one SimEvent object, e.g. <tt class="docutils literal"><span class="pre">myEvent</span></tt>, or</li>
<li>a tuple of SimEvent objects, e.g. <tt class="docutils literal"><span class="pre">(myEvent,myOtherEvent,TimeOut)</span></tt>, or</li>
<li>a list of SimEvent objects, e.g. <tt class="docutils literal"><span class="pre">[myEvent,myOtherEvent,TimeOut]</span></tt></li>
</ul>
<p>If none of the events in the <em>&lt;events part&gt;</em> have occurred, the process
is passivated and joined to the list of processes waiting for some
event in <em>&lt;events part&gt;</em> to occur (or to recur).</p>
<p>On the other hand, when <em>any</em> of the events in the <em>&lt;events part&gt;</em>
occur, then <em>all</em> of the processes &quot;waiting&quot; for those particular
events are reactivated at the current time. Then the <tt class="docutils literal"><span class="pre">occurred</span></tt> flag
of those particular events is reset to <tt class="docutils literal"><span class="pre">False</span></tt>. Resetting their
<tt class="docutils literal"><span class="pre">occurred</span></tt> flag prevents the waiting processes from being constantly
reactivated. (For instance, we do not want firemen to keep responding
to any such &quot;false alarms.&quot;)  For example, suppose the <em>&lt;events part&gt;</em>
lists events <tt class="docutils literal"><span class="pre">a,</span> <span class="pre">b</span></tt> and <tt class="docutils literal"><span class="pre">c</span></tt>  in that order. If events <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">c</span></tt>
occur, then all of the processes waiting for event <tt class="docutils literal"><span class="pre">a</span></tt> are
reactivated. So are all processes waiting for event <tt class="docutils literal"><span class="pre">c</span></tt> but not
<tt class="docutils literal"><span class="pre">a</span></tt>. Then the <tt class="docutils literal"><span class="pre">occurred</span></tt> flags of events <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">c</span></tt> are toggled to
<tt class="docutils literal"><span class="pre">False</span></tt>. No direct changes are made to event <tt class="docutils literal"><span class="pre">b</span></tt> or to any processes
waiting for it to occur.</p>
</li>
</ul>
<p>You program a process to &quot;queue&quot; for events by including in its PEM:</p>
</div>
<div class="section">
<h3><a id="yield-queueevent" name="yield-queueevent">yield queueevent</a></h3>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">yield</span> <span class="pre">queueevent,self,</span></tt><em>&lt;events part&gt;</em></p>
<p>where the  <em>&lt;events part&gt;</em> is as described above.</p>
<p>If none of the events in the <em>&lt;events part&gt;</em> has occurred, the process
is passivated and appended to the FIFO queue of processes queuing for
some event in <em>&lt;events part&gt;</em> to occur (or recur).</p>
<p>But when any of the events in <em>&lt;events part&gt;</em> occur, the process at
the head of the &quot;queue&quot; is taken off the queue and reactivated at the
current time. Then the <tt class="docutils literal"><span class="pre">occurred</span></tt> flag of those events that occurred
is reset to <tt class="docutils literal"><span class="pre">False</span></tt> as in the &quot;waiting&quot; case.</p>
</li>
</ul>
<div class="section">
<h4><a id="finding-which-processes-are-waiting-queueing-for-an-event-and-which-events-fired" name="finding-which-processes-are-waiting-queueing-for-an-event-and-which-events-fired">Finding Which Processes Are Waiting/Queueing for an Event, and Which Events Fired</a></h4>
<p>SimPy automatically keeps current lists of what processes are
&quot;waiting&quot; or &quot;queueing&quot; for SimEvents. They are kept in the <tt class="docutils literal"><span class="pre">waits</span></tt>
and <tt class="docutils literal"><span class="pre">queues</span></tt> attributes of the SimEvent object and can be read by
commands like the following:</p>
<pre class="literal-block">
TheProcessesWaitingFor_myEvent = myEvent.waits
TheProcessesQueuedFor_myEvent = myEvent.queues
</pre>
<p>However, you should not attempt to change these attributes yourself.</p>
<p>Whenever <tt class="docutils literal"><span class="pre">myEvent</span></tt> occurs, i.e., whenever a <tt class="docutils literal"><span class="pre">myEvent.signal(...)</span></tt>
statement is executed, SimPy does the following:</p>
<ul class="simple">
<li>If there are any processes waiting or queued for that event, it
reactivates them as described in the preceding section.</li>
<li>If there are no processes waiting or queued (i.e., <tt class="docutils literal"><span class="pre">myEvent.waits</span></tt>
and <tt class="docutils literal"><span class="pre">myEvent.queues</span></tt> are both empty), it toggles <tt class="docutils literal"><span class="pre">myEvent.occurred</span></tt>
to <tt class="docutils literal"><span class="pre">True</span></tt>.</li>
</ul>
<p>SimPy also automatically keeps track of which events were fired when a
process object was reactivated. For example, you can get a list of the
events that were fired when the object <tt class="docutils literal"><span class="pre">Godzilla</span></tt> was reactivated with
a statement like this:</p>
<pre class="literal-block">
GodzillaRevivedBy = Godzilla.eventsFired
</pre>
<hr class="docutils" />
<p id="example-6"><strong>Example 6</strong>. This complete SimPy script illustrates these
constructs. (It also illustrates that a Process class may have more
than one PEM. Here the <tt class="docutils literal"><span class="pre">Wait_Or_Queue</span></tt> class has two PEMs --
<tt class="docutils literal"><span class="pre">waitup</span></tt> and <tt class="docutils literal"><span class="pre">queueup</span></tt>.):</p>
<pre class="literal-block">
from SimPy.Simulation import *

class Wait_Or_Queue(Process):
    def waitup(self,myEvent):      # PEM illustrating &quot;waitevent&quot;
         # wait for &quot;myEvent&quot; to occur
        yield waitevent, self, myEvent
        print 'At %s, some SimEvent(s) occurred that \
             activated object %s.' %(now(), self.name)
        print '   The activating event(s) were %s' \
            %([x.name for x in self.eventsFired])

    def queueup(self, myEvent):    # PEM illustrating &quot;queueevent&quot;
         # queue up for &quot;myEvent&quot; to occur
        yield queueevent, self, myEvent
        print 'At %s, some SimEvent(s) occurred that \
            activated object %s.' %(now(), self.name)
        print '   The activating event(s) were %s' \
            %([x.name for x in self.eventsFired])

class Signaller(Process):
         # here we just schedule some events to fire
    def sendSignals(self):
        yield hold, self, 2
        event1.signal()        # fire &quot;event1&quot; at time 2
        yield hold, self, 8
        event2.signal()        # fire &quot;event2&quot; at time 10
        yield hold, self, 5
        event1.signal()        # fire all four events at time 15
        event2.signal()
        event3.signal()
        event4.signal()
        yield hold, self, 5
        event4.signal()        # event4 recurs at time 20

initialize()

         # Now create each SimEvent and give it a name
event1 = SimEvent('Event-1')
event2 = SimEvent('Event-2')
event3 = SimEvent('Event-3')
event4 = SimEvent('Event-4')
Event_list = [event3,event4]   # define an event list

s = Signaller()
         # Activate Signaller &quot;s&quot; *after* events created
activate (s,s.sendSignals())

w0 = Wait_Or_Queue('W-0')
         # create object named &quot;W-0&quot;, and set it to
         # &quot;waitup&quot; for SimEvent &quot;event1&quot; to occur
activate (w0, w0.waitup(event1))
w1 = Wait_Or_Queue('W-1')
activate (w1, w1.waitup(event2))
w2 = Wait_Or_Queue('W-2')
activate(w2, w2.waitup(Event_list))
q1 = Wait_Or_Queue('Q-1')
         # create object named &quot;Q-1&quot;, and put it to be first
         # in the queue for Event_list to occur
activate(q1, q1.queueup(Event_list))
q2 = Wait_Or_Queue('Q-2')
         # create object named &quot;Q-2&quot;, and append it to
         # the queue for Event_list to occur
activate(q2, q2.queueup(Event_list))

simulate(until=50)
</pre>
<p>This program outputs:</p>
<pre class="literal-block">
At 2, some SimEvent(s) occurred that activated object W-0.
   The activating event(s) were ['Event-1']
At 10, some SimEvent(s) occurred that activated object W-1.
   The activating event(s) were ['Event-2']
At 15, some SimEvent(s) occurred that activated object W-2.
   The activating event(s) were ['Event-3']
At 15, some SimEvent(s) occurred that activated object Q-1.
   The activating event(s) were ['Event-3', 'Event-4']
At 20, some SimEvent(s) occurred that activated object Q-2.
   The activating event(s) were ['Event-4']
</pre>
<p>Each output line, <tt class="docutils literal"><span class="pre">The</span> <span class="pre">activating</span> <span class="pre">event(s)</span> <span class="pre">were</span> <span class="pre">...</span></tt>, lists the
contents of the named object's <tt class="docutils literal"><span class="pre">eventsFired</span></tt> attribute. One of those
events &quot;caused&quot; the object to reactivate at the indicated time. Note
that at time 15 objects <tt class="docutils literal"><span class="pre">W-0</span></tt> and <tt class="docutils literal"><span class="pre">W-1</span></tt> were not affected by the
recurrence of <tt class="docutils literal"><span class="pre">event1</span></tt> and <tt class="docutils literal"><span class="pre">event2</span></tt> because they already were
active. Also at time 15, even though objects <tt class="docutils literal"><span class="pre">W-2</span></tt>, <tt class="docutils literal"><span class="pre">Q-1</span></tt> and <tt class="docutils literal"><span class="pre">Q-2</span></tt>
were all waiting for <tt class="docutils literal"><span class="pre">event3</span></tt>, only <tt class="docutils literal"><span class="pre">W-2</span></tt> and <tt class="docutils literal"><span class="pre">Q-1</span></tt> were
reactivated. Process object <tt class="docutils literal"><span class="pre">Q-2</span></tt> was not reactivated at that time
because it was not first in the queue.  Finally, <tt class="docutils literal"><span class="pre">Q-2</span></tt> was reactivated
at time 20, when <tt class="docutils literal"><span class="pre">event4</span></tt> fired again.</p>
<hr class="docutils" />
</div>
</div>
<div class="section">
<h3><a id="waituntil-synchronization-waiting-for-any-condition" name="waituntil-synchronization-waiting-for-any-condition"><span id="wait-until"></span>&quot;waituntil&quot; synchronization -- waiting for any condition</a></h3>
<p>SimPy provides the <tt class="docutils literal"><span class="pre">waituntil</span></tt> feature that makes a process's
progress depend on the state of the simulation. This is useful if, for
example, you need to reactivate a process when (if ever) the
simulation enters the state <tt class="docutils literal"><span class="pre">goodWeather</span> <span class="pre">OR</span> <span class="pre">(nrCustomers&gt;50</span> <span class="pre">AND</span>
<span class="pre">price&lt;22.50)</span></tt>.  Doing that requires <em>interrogative</em> scheduling,
while all other SimPy synchronization constructs are <em>imperative</em> --
i.e., the condition must be tested after every change in state until
it becomes <tt class="docutils literal"><span class="pre">True</span></tt>.</p>
<p>This requires that after every change in system state SimPy must run a
special (hidden) process that tests and responds appropriately to the
condition's truth-value. This clearly takes more run time than SimPy's
imperative scheduling constructs. So SimPy activates its interrogative
testing process only so long as at least one process is executing a
<tt class="docutils literal"><span class="pre">waituntil</span></tt> statement. When this is not the case, the run time overhead
is minimal (about 1 percent extra run time).</p>
</div>
<div class="section">
<h3><a id="yield-waituntil" name="yield-waituntil">yield waituntil</a></h3>
<p>You program a process to wait for a condition to be satisfied by
including in its PEM a statement of the form:</p>
<blockquote>
<tt class="docutils literal"><span class="pre">yield</span> <span class="pre">waituntil,</span> <span class="pre">self,</span></tt><em>&lt;cond&gt;</em></blockquote>
<p>where <em>&lt;cond&gt;</em> is a reference to a function, without parameters, that
returns a Boolean value indicating whether the simulation state or
condition to be waited for has occurred.</p>
<hr class="docutils" />
<p id="example-7"><span id="romulans"></span><strong>Example 7</strong>. This program using the <tt class="docutils literal"><span class="pre">yield</span> <span class="pre">waituntil</span> <span class="pre">...</span></tt>
statement. Here the function <tt class="docutils literal"><span class="pre">killed()</span></tt>, in the <tt class="docutils literal"><span class="pre">life()</span></tt> PEM of
the <tt class="docutils literal"><span class="pre">Player</span></tt> process, defines the condition to be waited for</p>
<pre class="literal-block">
from SimPy.Simulation import *
import random

class Player(Process):

  def __init__(self,lives=1,name='ImaTarget'):
    Process.__init__(self,name)
    self.lives=lives
      # provide Player objects with a &quot;damage&quot; property
    self.damage=0

  def life(self):
    self.message='Drat! Some %s survived Federation attack!' %(target.name)

    def killed():     # function testing for &quot;damage &gt; 5&quot;
      return self.damage&gt;5

    while True:
      yield waituntil,self,killed
      self.lives-=1; self.damage=0
      if self.lives==0:
        self.message= '%s wiped out by Federation at \
          time %s!' %(target.name,now())
        stopSimulation()

class Federation(Process):

  def fight(self):                # simulate Federation operations
    print 'Three %s attempting to escape!' %(target.name)
    while True:
      if random.randint(0,10)&lt;2:  # check for hit on player
        target.damage+=1          # hit! increment damage to player
        if target.damage &lt;= 5:    # target survives
          print 'Ha! %s hit! Damage = %i'%(target.name, target.damage)
        else:
          if (target.lives-1)==0:
            print 'No more %s left!' %(target.name)
          else:
            print 'Now only %i %s left!' %(target.lives-1,target.name)

      yield hold,self,1

initialize()
gameOver=100
  # create a Player object named &quot;Romulans&quot;
target=Player(lives=3,name='Romulans')
activate(target,target.life())
  # create a Federation object
shooter=Federation()
activate(shooter,shooter.fight())
simulate(until=gameOver)
print target.message
</pre>
<p>One possible output from this program is shown below. Whether the
Romulans are wiped out or some escape depends on what simulation
states the randomization feature produces:</p>
<pre class="literal-block">
Three Romulans attempting to escape!
Ha! Romulans hit! Damage = 1
Ha! Romulans hit! Damage = 2
Ha! Romulans hit! Damage = 3
Ha! Romulans hit! Damage = 4
Ha! Romulans hit! Damage = 5
  Now only 2 Romulans left!
Ha! Romulans hit! Damage = 1
Ha! Romulans hit! Damage = 2
Ha! Romulans hit! Damage = 3
Ha! Romulans hit! Damage = 4
Ha! Romulans hit! Damage = 5
  Now only 1 Romulans left!
Ha! Romulans hit! Damage = 1
Ha! Romulans hit! Damage = 2
Ha! Romulans hit! Damage = 3
Ha! Romulans hit! Damage = 4
Ha! Romulans hit! Damage = 5
  No more Romulans left!
Romulans wiped out by Federation at time 73!
</pre>
<hr class="docutils" />
<p>The <tt class="docutils literal"><span class="pre">waituntil</span></tt> construct is so general that in principle it could
replace all the other synchronization approaches (but at a run time
cost).</p>
<p>[Return to <a class="reference" href="#contents">Top</a> ]</p>
<!-- ================================================================== -->
</div>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id29" id="resources" name="resources">4&nbsp;&nbsp;&nbsp;Resources</a></h1>
<p>The three resource facilities provided by SimPy are <a class="reference" href="#resources">Resources</a>,
<a class="reference" href="#levels">Levels</a> and <a class="reference" href="#stores">Stores</a>. Each models a congestion point where process
objects may have to queue up to obtain resources. This section
describes the Resource type of resource facility.</p>
<p>An example of queueing for a Resource might be a manufacturing plant
in which a <tt class="docutils literal"><span class="pre">Task</span></tt> (modeled as a <em>process object</em>) needs work done
by a <tt class="docutils literal"><span class="pre">Machine</span></tt> (modeled as a Resource object). If all of the
<tt class="docutils literal"><span class="pre">Machines</span></tt> are currently being used, the <tt class="docutils literal"><span class="pre">Task</span></tt> must wait until
one becomes free. A SimPy Resource can have a number of identical
<tt class="docutils literal"><span class="pre">units</span></tt>, such as a number of identical <tt class="docutils literal"><span class="pre">machine</span></tt> units. A
process obtains a unit of the Resource by <tt class="docutils literal"><span class="pre">requesting</span></tt> it and, when
it is finished, <tt class="docutils literal"><span class="pre">releasing</span></tt> it. A Resource maintains a list of
process objects that have requested but not yet received one of the
Resource's units (called the <tt class="docutils literal"><span class="pre">waitQ</span></tt>), and another list of processes
that are currently using a unit (the <tt class="docutils literal"><span class="pre">activeQ</span></tt>).  SimPy creates and
updates these queues itself -- the user can access them, but should
not change them.</p>
<div class="section">
<h2><a class="toc-backref" href="#id30" id="defining-a-resource-object" name="defining-a-resource-object">4.1&nbsp;&nbsp;&nbsp;Defining a Resource object</a></h2>
<p>A Resource object, <tt class="docutils literal"><span class="pre">r</span></tt>,  is established by the following statement:</p>
<pre class="literal-block">
r = Resource(capacity=1, name='a_resource', unitName='units',
           qType=FIFO, preemptable=False,
           monitored=False, monitorType=Monitor)
</pre>
<p>where</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">capacity</span></tt> is a positive real or integer value that specifies the total
number of identical units in Resource object <tt class="docutils literal"><span class="pre">r</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">name</span></tt> is a descriptive name for this Resource object (e.g.,
<tt class="docutils literal"><span class="pre">'gasStation'</span></tt>).</li>
<li><tt class="docutils literal"><span class="pre">unitName</span></tt> is a descriptive name for a unit of the resource
(e.g., <tt class="docutils literal"><span class="pre">'pump'</span></tt>).</li>
<li><tt class="docutils literal"><span class="pre">qType</span></tt> is either <tt class="docutils literal"><span class="pre">FIFO</span></tt> <a class="footnote-reference" href="#fifo" id="id14" name="id14">[7]</a> or <tt class="docutils literal"><span class="pre">PriorityQ</span></tt>. It
specifies the queue discipline of the resource's <tt class="docutils literal"><span class="pre">waitQ</span></tt>;
typically, this is <tt class="docutils literal"><span class="pre">FIFO</span></tt> and that is the default value. If
<tt class="docutils literal"><span class="pre">PriorityQ</span></tt> is specified, then higher-priority requests waiting
for a unit of Resource <tt class="docutils literal"><span class="pre">r</span></tt> are inserted into the <tt class="docutils literal"><span class="pre">waitQ</span></tt> ahead
of lower priority requests.  See <a class="reference" href="#priority-requests-for-a-resource-unit">Priority requests for a Resource
unit</a> for details.</li>
<li><tt class="docutils literal"><span class="pre">preemptable</span></tt> is a Boolean (<tt class="docutils literal"><span class="pre">False</span></tt> or <tt class="docutils literal"><span class="pre">True</span></tt>); typically,
this is <tt class="docutils literal"><span class="pre">False</span></tt> and that is the default value. If it is
<tt class="docutils literal"><span class="pre">True</span></tt>, then a process requesting a unit of this resource may
preempt a lower-priority process in the <tt class="docutils literal"><span class="pre">activeQ</span></tt>, i.e., one that
is already using a unit of the resource.  See <a class="reference" href="#preemptive-requests-for-a-resource-unit">Preemptive requests
for a Resource unit</a> for details.</li>
<li><tt class="docutils literal"><span class="pre">monitored</span></tt> is a boolean (<tt class="docutils literal"><span class="pre">False</span></tt> or <tt class="docutils literal"><span class="pre">True</span></tt>). If set to
<tt class="docutils literal"><span class="pre">True</span></tt>, then information is gathered on the sizes of <tt class="docutils literal"><span class="pre">r</span></tt>'s
<tt class="docutils literal"><span class="pre">waitQ</span></tt> and <tt class="docutils literal"><span class="pre">activeQ</span></tt>, otherwise not.</li>
<li><tt class="docutils literal"><span class="pre">monitorType</span></tt> is either <tt class="docutils literal"><span class="pre">Monitor</span></tt> or <tt class="docutils literal"><span class="pre">Tally</span></tt> and indicates the
type of <a class="reference" href="#recording-simulation-results">Recorder</a> to be used (see <a class="reference" href="#recording-resource-queue-lengths">Recording
Resource queue lengths</a> for an example and additional
discussion).</li>
</ul>
</blockquote>
<p>Each Resource object, <tt class="docutils literal"><span class="pre">r</span></tt>,  has the following additional attributes:</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">r.n</span></tt>,  the number of units that are currently free.</li>
<li><tt class="docutils literal"><span class="pre">r.waitQ</span></tt>, a queue (list) of processes that have requested but
not yet received a unit of <tt class="docutils literal"><span class="pre">r</span></tt>, so <tt class="docutils literal"><span class="pre">len(r.waitQ)</span></tt> is the
number of process objects currently waiting.</li>
<li><tt class="docutils literal"><span class="pre">r.activeQ</span></tt>, a queue (list) of process objects currently using
one of the Resource's units, so <tt class="docutils literal"><span class="pre">len(r.activeQ)</span></tt> is the number of
units that are currently in use.</li>
<li><tt class="docutils literal"><span class="pre">r.waitMon</span></tt>, the record (made by a <tt class="docutils literal"><span class="pre">Monitor</span></tt> or a <tt class="docutils literal"><span class="pre">Tally</span></tt>
whenever <tt class="docutils literal"><span class="pre">monitored==True</span></tt>) of the activity in <tt class="docutils literal"><span class="pre">r.waitQ</span></tt>. So,
for example, <tt class="docutils literal"><span class="pre">r.waitMon.timeaverage()</span></tt> is the average number of
processes in <tt class="docutils literal"><span class="pre">r.waitQ</span></tt>.  See <a class="reference" href="#recording-resource-queue-lengths">Recording Resource queue lengths</a>
for an example.</li>
<li><tt class="docutils literal"><span class="pre">r.actMon</span></tt>, the record (made by a <tt class="docutils literal"><span class="pre">Monitor</span></tt> or a <tt class="docutils literal"><span class="pre">Tally</span></tt> whenever
<tt class="docutils literal"><span class="pre">monitored==True</span></tt>) of the activity in <tt class="docutils literal"><span class="pre">r.activeQ</span></tt>.</li>
</ul>
</blockquote>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id31" id="requesting-and-releasing-a-unit-of-a-resource" name="requesting-and-releasing-a-unit-of-a-resource">4.2&nbsp;&nbsp;&nbsp;Requesting and releasing a unit of a Resource</a></h2>
<p>A process can request and later release a unit of the Resource object,
<tt class="docutils literal"><span class="pre">r</span></tt>, by using the following yield commands in a Process Execution
Method:</p>
<div class="section">
<h3><a id="yield-request" name="yield-request">yield request</a></h3>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">yield</span> <span class="pre">request,self,</span></tt><em>r [,P=0]</em></p>
<p>requests a unit of Resource <em>r</em> with (optional) real or integer
priority value <em>P</em>. If no priority is specified, it defaults to 0.
Larger values of <em>P</em> represent higher priorities. See the following
sections on <a class="reference" href="#queue-order">Queue Order</a> for more information on how priority
values are used.  Although this form of request can be used for
either <tt class="docutils literal"><span class="pre">FIFO</span></tt> or <tt class="docutils literal"><span class="pre">PriorityQ</span></tt> priority types, these values are
<em>ignored</em> when <tt class="docutils literal"><span class="pre">qType==FIFO</span></tt>.</p>
</li>
</ul>
</div>
<div class="section">
<h3><a id="yield-release" name="yield-release">yield release</a></h3>
<blockquote>
<p><tt class="docutils literal"><span class="pre">yield</span> <span class="pre">release,self,r</span></tt></p>
<p>releases the  unit of <em>r</em>.</p>
</blockquote>
<!-- ================================================================== -->
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id32" id="queue-order" name="queue-order">4.3&nbsp;&nbsp;&nbsp;Queue Order</a></h2>
<p>If a requesting process must wait it is placed into the resource's
<tt class="docutils literal"><span class="pre">waitQ</span></tt> in an order determined by settings of the resource's
<tt class="docutils literal"><span class="pre">qType</span></tt> and <tt class="docutils literal"><span class="pre">preemptable</span></tt> attributes and of the priority value it
uses in the <tt class="docutils literal"><span class="pre">request</span></tt> call.</p>
<div class="section">
<h3><a id="non-priority-queueing" name="non-priority-queueing">Non-priority queueing</a></h3>
<p>If the <tt class="docutils literal"><span class="pre">qType</span></tt> is not specified it takes the presumed value of
<tt class="docutils literal"><span class="pre">FIFO</span></tt> <a class="footnote-reference" href="#fifo" id="id15" name="id15">[7]</a>. In that case processes wait in the usual
first-come-first-served order.</p>
<p>If a Resource unit is free when the request is made, the requesting
process takes it and moves on to the next statement in its PEM. If no
Resource unit is available when the request is made, then the
requesting process is appended to the Resource's <tt class="docutils literal"><span class="pre">waitQ</span></tt> and
suspended.  The next time a unit becomes available the first process
in the <tt class="docutils literal"><span class="pre">r.waitQ</span></tt> takes it and continues its execution. All priority
assignments are ignored. Moreover, in the FIFO case no preemption is
possible, for preemption requires that priority assignments be
recognized. (However, see the <a class="reference" href="#note-on-preemptive-requests-with-waitq-in-fifo-order">Note on preemptive requests with waitQ
in FIFO order</a> for one way of simulating such situations.)</p>
<hr class="docutils" />
<p><strong>Example</strong> In this complete script, the <tt class="docutils literal"><span class="pre">server</span></tt> Resource object is
given two resource units (<tt class="docutils literal"><span class="pre">capacity=2</span></tt>). By not specifying its
<tt class="docutils literal"><span class="pre">Qtype</span></tt> it takes the default value, <tt class="docutils literal"><span class="pre">FIFO</span></tt>.  Here six clients
arrive in the order specified by the program. They all request a
resource unit from the <tt class="docutils literal"><span class="pre">server</span></tt> Resource object at the same
time. Even though they all specify a priority value in their requests,
it is ignored and they get their Resource units in the same order as
their requests:</p>
<pre class="literal-block">
from SimPy.Simulation import *
class Client(Process):
    inClients=[]   # list the clients in order by their requests
    outClients=[]  # list the clients in order by completion of service

    def __init__(self,name):
       Process.__init__(self,name)

    def getserved(self,servtime,priority,myServer):
        Client.inClients.append(self.name)
        print self.name, 'requests 1 unit at t =',now()
         # request use of a resource unit
        yield request, self, myServer, priority
        yield hold, self, servtime
         # release the resource
        yield release, self, myServer
        print self.name,'done at t =',now()
        Client.outClients.append(self.name)

initialize()

    # the next line creates the ``server`` Resource object
server=Resource(capacity=2)     # server defaults to qType==FIFO

    # the next lines create some Client process objects
c1=Client(name='c1') ; c2=Client(name='c2')
c3=Client(name='c3') ; c4=Client(name='c4')
c5=Client(name='c3') ; c6=Client(name='c6')

    # in the next lines each client requests 
    # one of the ``server``'s Resource units
activate(c1,c1.getserved(servtime=100,priority=1,myServer=server))
activate(c2,c2.getserved(servtime=100,priority=2,myServer=server))
activate(c3,c3.getserved(servtime=100,priority=3,myServer=server))
activate(c4,c4.getserved(servtime=100,priority=4,myServer=server))
activate(c5,c5.getserved(servtime=100,priority=5,myServer=server))
activate(c6,c6.getserved(servtime=100,priority=6,myServer=server))

simulate(until=500)

print 'Request order: ',Client.inClients
print 'Service order: ',Client.outClients

</pre>
<p>This program results in the following output:</p>
<pre class="literal-block">
c1 requests 1 unit at t = 0
c2 requests 1 unit at t = 0
c3 requests 1 unit at t = 0
c4 requests 1 unit at t = 0
c5 requests 1 unit at t = 0
c6 requests 1 unit at t = 0
c1 done at time = 100
c2 done at time = 100
c3 done at time = 200
c4 done at time = 200
c5 done at time = 300
c6 done at time = 300

Request order:  ['c1', 'c2', 'c3', 'c4', 'c5', 'c6']
Service order:  ['c1', 'c2', 'c3', 'c4', 'c5', 'c6']
</pre>
<p>As illustrated, the clients are served in FIFO order. Clients <tt class="docutils literal"><span class="pre">c1</span></tt>
and <tt class="docutils literal"><span class="pre">c2</span></tt> each take one Resource unit right away, but the others must
wait. When <tt class="docutils literal"><span class="pre">c1</span></tt> and <tt class="docutils literal"><span class="pre">c2</span></tt> finish with their resources, clients
<tt class="docutils literal"><span class="pre">c3</span></tt> and <tt class="docutils literal"><span class="pre">c4</span></tt> can each take a unit, and so forth.</p>
</div>
<div class="section">
<h3><a id="priority-requests-for-a-resource-unit" name="priority-requests-for-a-resource-unit">Priority requests for a Resource unit</a></h3>
<p>If the Resource <tt class="docutils literal"><span class="pre">r</span></tt> is defined with <tt class="docutils literal"><span class="pre">qType==PriorityQ</span></tt>, priority
values in requests are recognized.  If a Resource unit is available
when the request is made, the requesting process takes it. If no
Resource unit is available when the request is made, the requesting
process is inserted into the Resource's <tt class="docutils literal"><span class="pre">waitQ</span></tt> in order of priority
(from high to low) and suspended. For an example where priorities are
used, we simply change the preceding example's specification of the
<tt class="docutils literal"><span class="pre">server</span></tt> Resource object to:</p>
<pre class="literal-block">
server=Resource(capacity=2, qType=PriorityQ)
</pre>
<p>where, by not specifying it, we allow <tt class="docutils literal"><span class="pre">preemptable</span></tt> to take its
default value, <tt class="docutils literal"><span class="pre">False</span></tt>.</p>
<hr class="docutils" />
<p><strong>Example</strong> After this change the program's output becomes:</p>
<pre class="literal-block">
c1 requests 1 unit at t = 0
c2 requests 1 unit at t = 0
c3 requests 1 unit at t = 0
c4 requests 1 unit at t = 0
c5 requests 1 unit at t = 0
c6 requests 1 unit at t = 0
c1 done at time = 100
c2 done at time = 100
c6 done at time = 200
c5 done at time = 200
c4 done at time = 300
c3 done at time = 300

Request order:  ['c1', 'c2', 'c3', 'c4', 'c5', 'c6']
Service order:  ['c1', 'c2', 'c6', 'c5', 'c4', 'c3']
</pre>
<p>Although <tt class="docutils literal"><span class="pre">c1</span></tt> and <tt class="docutils literal"><span class="pre">c2</span></tt> have the lowest priority values, each requested
and got a <tt class="docutils literal"><span class="pre">server</span></tt> unit immediately. That was because at the time they
made those requests a <tt class="docutils literal"><span class="pre">server</span></tt> unit was available and the
<tt class="docutils literal"><span class="pre">server.waitQ</span></tt> was empty -- it did not start to fill until <tt class="docutils literal"><span class="pre">c3</span></tt> made
its request and found all of the <tt class="docutils literal"><span class="pre">server</span></tt> units busy. When <tt class="docutils literal"><span class="pre">c1</span></tt> and
<tt class="docutils literal"><span class="pre">c2</span></tt> completed service, <tt class="docutils literal"><span class="pre">c6</span></tt> and <tt class="docutils literal"><span class="pre">c5</span></tt> (with the highest priority
values of all processes in the <tt class="docutils literal"><span class="pre">waitQ</span></tt>) each got a Resource unit,
etc.</p>
<hr class="docutils" />
<p>When some processes in the <tt class="docutils literal"><span class="pre">waitQ</span></tt> have the same priority level as a
process making a priority request, SimPy inserts the requesting
process immediately <em>behind</em> them. Thus for a given priority value,
processes are placed in FIFO order. For example, suppose that when a
&quot;priority 3&quot; process makes its priority request the current <tt class="docutils literal"><span class="pre">waitQ</span></tt>
consists of processes with priorities <tt class="docutils literal"><span class="pre">[5,4,3a,3b,3c,2a,2b,1]</span></tt>,
where the letters indicate the order in which the equal-priority
processes were placed in the queue.  Then SimPy inserts this
requesting process into the current <tt class="docutils literal"><span class="pre">waitQ</span></tt> immediately behind its
last &quot;priority 3&quot; process. Thus, the new <tt class="docutils literal"><span class="pre">waitQ</span></tt> will be
<tt class="docutils literal"><span class="pre">[5,4,3a,3b,3c,3d,2a,2b,1]</span></tt>, where the inserted process is <tt class="docutils literal"><span class="pre">3d</span></tt>.</p>
<p>One consequence of this is that, if all priority requests are assigned
the same priority value, then the <tt class="docutils literal"><span class="pre">waitQ</span></tt> will in fact be maintained
in <tt class="docutils literal"><span class="pre">FIFO</span></tt> order. In that case, using a <tt class="docutils literal"><span class="pre">FIFO</span></tt> instead of a
<tt class="docutils literal"><span class="pre">PriorityQ</span></tt> discipline provides some saving in execution time which
may be important in simulations where the <tt class="docutils literal"><span class="pre">waitQ</span></tt> may be long.</p>
</div>
<div class="section">
<h3><a id="preemptive-requests-for-a-resource-unit" name="preemptive-requests-for-a-resource-unit">Preemptive requests for a Resource unit</a></h3>
<p>In some models, higher priority processes can actually <em>preempt</em> lower
priority processes, i.e., they can take over and use a Resource unit
currently being used by a lower priority process whenever no free
Resource units are available. A Resource object that allows its units
to be preempted is created by setting its properties to
<tt class="docutils literal"><span class="pre">qType==PriorityQ</span></tt> and <tt class="docutils literal"><span class="pre">preemptable==True</span></tt>.</p>
<p>Whenever a <tt class="docutils literal"><span class="pre">preemptable</span></tt> Resource unit is free when a request is
made, then the requesting process takes it and continues its
execution. On the other hand, when a higher priority request finds all
the units in a <tt class="docutils literal"><span class="pre">preemptable</span></tt> Resource in use, then SimPy adopts the
following procedure regarding the Resource's <tt class="docutils literal"><span class="pre">activeQ</span></tt> and
<tt class="docutils literal"><span class="pre">waitQ</span></tt>:</p>
<ul class="simple">
<li>The process with the lowest priority is removed from the <tt class="docutils literal"><span class="pre">activeQ</span></tt>,
suspended, and put at the front of the <tt class="docutils literal"><span class="pre">waitQ</span></tt> -- so (barring
additional preemptions) it will be the next one to get a resource
unit.</li>
<li>The preempting process gets the vacated resource unit and is
inserted into the <tt class="docutils literal"><span class="pre">activeQ</span></tt> in order of its priority value.</li>
<li>The time for which the preempted process had the resource unit is
taken into account when the process gets into the <tt class="docutils literal"><span class="pre">activeQ</span></tt> again.
Thus, its <em>total hold time</em> is always the same, regardless of how
many times it has been preempted.</li>
</ul>
<p>Warning: SimPy only supports preemption of processes which are
implemented in the following pattern:</p>
<pre class="literal-block">
yield request (one or more request statements)
&lt;some code&gt;
yield hold (one or more hold statements)
&lt;some code&gt;
yield release (one or more release statements)
</pre>
<p>Modeling the preemption of a process in any other pattern may lead to
errors or exceptions.</p>
<p>We emphasize that a process making a <tt class="docutils literal"><span class="pre">preemptive</span></tt> request to a
fully-occupied Resource gets a resource unit if -- but only if -- some
process in the current <tt class="docutils literal"><span class="pre">activeQ</span></tt> has a lower priority. Otherwise, it
will be inserted into the <tt class="docutils literal"><span class="pre">waitQ</span></tt> at a location determined by its
priority value and the current contents of the <tt class="docutils literal"><span class="pre">waitQ</span></tt>, using a
procedure analogous to that described for priority requests near the
end of the preceding section on <a class="reference" href="#priority-requests-for-a-resource-unit">Priority requests for a Resource
unit</a>. This may have the effect of advancing the preempting process
ahead of any lower-priority processes that had earlier been preempted
and put at the head of the <tt class="docutils literal"><span class="pre">waitQ</span></tt>. In fact, if several preemptions
occur before a unit of resource is freed up, then the head of the
<tt class="docutils literal"><span class="pre">waitQ</span></tt> will consist of the processes that have been preempted -- in
order from the last process preempted to the first of them.</p>
<hr class="docutils" />
<p><strong>Example</strong> In this example two clients of different priority compete
for the same resource unit:</p>
<pre class="literal-block">
from SimPy.Simulation import *
class Client(Process):
def __init__(self,name):
   Process.__init__(self,name)

def getserved(self,servtime,priority,myServer):
    print self.name, 'requests 1 unit at t=',now()
    yield request, self, myServer, priority
    yield hold, self, servtime
    yield release, self,myServer
    print self.name,'done at t= ',now()

initialize()
  # create the *server* Resource object
server=Resource(capacity=1,qType=PriorityQ,preemptable=1)
  # create some Client process objects
c1=Client(name='c1')
c2=Client(name='c2')
activate(c1,c1.getserved(servtime=100,priority=1,myServer=server),at=0)
activate(c2,c2.getserved(servtime=100,priority=9,myServer=server),at=50)
simulate(until=500)
</pre>
<p>The output from this program is:</p>
<pre class="literal-block">
c1 requests 1 unit at t= 0
c2 requests 1 unit at t= 50
c2 done at t= 150
c1 done at t= 200
</pre>
<p>Here, <tt class="docutils literal"><span class="pre">c1</span></tt> is preempted by <tt class="docutils literal"><span class="pre">c2</span></tt> at <tt class="docutils literal"><span class="pre">t=50</span></tt>. At that time, <tt class="docutils literal"><span class="pre">c1</span></tt>
had held the resource for 50 of its total of 100 time units. When
<tt class="docutils literal"><span class="pre">c2</span></tt> finished and released the resource unit at 150, <tt class="docutils literal"><span class="pre">c1</span></tt> got the
resource back and finished the last 50 time units of its service at
<tt class="docutils literal"><span class="pre">t=200</span></tt>.</p>
<hr class="docutils" />
<p>If preemption occurs when the last few processes in the current
<tt class="docutils literal"><span class="pre">activeQ</span></tt> have the same priority value, then the last process in the
current <tt class="docutils literal"><span class="pre">activeQ</span></tt> is the one that will be preempted and inserted
into the <tt class="docutils literal"><span class="pre">waitQ</span></tt> ahead of all others.  To describe this, it will be
convenient to indicate by an added letter the order in which
equal-priority processes have been inserted into a queue. Now, suppose
that a &quot;priority 4&quot; process makes a preemptive request when the
current <tt class="docutils literal"><span class="pre">activeQ</span></tt> priorities are <tt class="docutils literal"><span class="pre">[5,3a,3b]</span></tt> and the current
<tt class="docutils literal"><span class="pre">waitQ</span></tt> priorities are <tt class="docutils literal"><span class="pre">[2,1,0a,0b]</span></tt>. Then process <tt class="docutils literal"><span class="pre">3b</span></tt> will be
preempted.  After the preemption the <tt class="docutils literal"><span class="pre">activeQ</span></tt> will be <tt class="docutils literal"><span class="pre">[5,4,3a]</span></tt>
and the <tt class="docutils literal"><span class="pre">waitQ</span></tt> will be <tt class="docutils literal"><span class="pre">[3b,2,1,0a,0b]</span></tt>.</p>
<!-- To give another example of how this works, consider the following sequence of
events, where several preemptive requests are received by a Resource with
two Resource units. Throughout this example, we give the ``activeQ``
before the ``waitQ``:

1. The current ``activeQ`` and ``waitQ`` are [1a,1b] and [0a,0b],
   respectively.

2. A "priority 5" process makes a preemptive request. Then the queues
   become: [5,1a] and [1b,0a,0b].

3. A "priority 3" process makes a preemptive request. Then the queues
   become: [5,3a] and [1a,1b,0a,0b].

4. Another "priority 3" process makes a preemptive request. Then the
   queues become: [5,3a] and [3b,1a,1b,0a,0b].

5. A "priority 7" process makes a preemptive request. Then the queues
   become: [7,5] and [3a,3b,1a,1b,0a,0b].

6. The "priority 7" process finishes using its resource unit. Then the
   queues become: [5,3a] and [3b,1a,1b,0a,0b]. -->
</div>
<div class="section">
<h3><a id="note-on-preemptive-requests-with-waitq-in-fifo-order" name="note-on-preemptive-requests-with-waitq-in-fifo-order">Note on preemptive requests with waitQ in FIFO order</a></h3>
<p>You may consider doing the following to model a system whose queue of
items waiting for a resource is to be maintained in FIFO order, but in
which preemption is to be possible. It uses SimPy's <tt class="docutils literal"><span class="pre">preemptable</span></tt>
Resource objects, and uses priorities in a way that allows for
preempts while maintaining a FIFO <tt class="docutils literal"><span class="pre">waitQ</span></tt> order.</p>
<ul class="simple">
<li>Set <tt class="docutils literal"><span class="pre">qType=PriorityQ</span></tt> and <tt class="docutils literal"><span class="pre">preemptable=True</span></tt> (so that SimPy
will process preemptive requests correctly).</li>
<li>Model &quot;system requests that are to be considered as non-preemptive&quot;
in SimPy as process objects each of which has exactly the same
(low) priority value -- for example, either assign all of them a
priority value of 0 (zero) or let it default to that value.  (This
has the effect of maintaining all of these process objects in the
<tt class="docutils literal"><span class="pre">waitQ</span></tt> in FIFO order, as explained at the end of the section on
<a class="reference" href="#priority-requests-for-a-resource-unit">Priority requests for a Resource unit</a>, above.)</li>
<li>Model &quot;system requests that are to be considered as preemptive&quot; in
SimPy as process objects each of which is assigned a uniform
priority value, but give them a higher value than the one used to
model the &quot;non-preemptive system requests&quot; -- for example, assign
all of them a priority value of 1 (one). Then they will have a higher
priority value than any of the non-preemptive requests.</li>
</ul>
<hr class="docutils" />
<p><strong>Example</strong> Here is an example of how this works for a Resource with
two Resource units -- we give the <tt class="docutils literal"><span class="pre">activeQ</span></tt> before the <tt class="docutils literal"><span class="pre">waitQ</span></tt>
throughout this example:</p>
<ol class="arabic simple">
<li>Suppose that the current <tt class="docutils literal"><span class="pre">activeQ</span></tt> and <tt class="docutils literal"><span class="pre">waitQ</span></tt> are <tt class="docutils literal"><span class="pre">[0a,0b]</span></tt>
and <tt class="docutils literal"><span class="pre">[0c],</span></tt> respectively.</li>
<li>A &quot;priority 1&quot; process makes a preemptive request. Then the queues
become: <tt class="docutils literal"><span class="pre">[1a,0a]</span></tt> and`` [0b,0c]``.</li>
<li>Another &quot;priority 1&quot; process makes a preemptive request. Then the
queues become: <tt class="docutils literal"><span class="pre">[1a,1b]</span></tt> and <tt class="docutils literal"><span class="pre">[0a,0b,0c]</span></tt>.</li>
<li>A third &quot;priority 1&quot; process makes a preemptive request. Then the
queues become: <tt class="docutils literal"><span class="pre">[1a,1b]</span></tt> and <tt class="docutils literal"><span class="pre">[1c,0a,0b,0c]</span></tt>.</li>
<li>Process <tt class="docutils literal"><span class="pre">1a</span></tt> finishes using its resource unit. Then the queues
become: <tt class="docutils literal"><span class="pre">[1b,1c]</span></tt> and <tt class="docutils literal"><span class="pre">[0a,0b,0c]</span></tt>.</li>
</ol>
<hr class="docutils" />
<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id33" id="reneging-leaving-a-queue-before-acquiring-a-resource" name="reneging-leaving-a-queue-before-acquiring-a-resource">4.4&nbsp;&nbsp;&nbsp;Reneging -- leaving a queue before acquiring a resource</a></h2>
<p>In most real world situations, people and other items do not wait
forever for a requested resource facility to become
available. Instead, they leave its queue when their patience is
exhausted or when some other condition occurs. This behavior is
called <em>reneging</em>, and the reneging person or thing is said to
<em>renege</em>.</p>
<p>SimPy provides an extended (i.e., compound) <tt class="docutils literal"><span class="pre">yield</span> <span class="pre">request</span></tt> statement
to handle reneging.</p>
<div class="section">
<h3><a id="reneging-yield-request" name="reneging-yield-request">Reneging yield request</a></h3>
<p>There are two types of reneging clause, one for reneging after a
certain time and one for reneging when an event has happened.
Their general form is</p>
<blockquote>
<tt class="docutils literal"><span class="pre">yield</span> <span class="pre">(request,self,</span></tt><em>r [,P]</em><tt class="docutils literal"><span class="pre">),</span></tt><tt class="docutils literal"><span class="pre">(</span></tt><em>&lt;reneging clause&gt;</em><tt class="docutils literal"><span class="pre">)</span></tt></blockquote>
<p>to request a unit of Resource <em>r</em> (with optional priority <em>P</em>,
assuming the Resource has been defined as a <tt class="docutils literal"><span class="pre">priorityQ</span></tt>) but with
reneging.</p>
<p>A SimPy program that models Resource requests with reneging must use
the following pattern of statements:</p>
<pre class="literal-block">
yield (request,self,r),(&lt;reneging clause&gt;)
if self.acquired(resource):
   ## process got resource and so did NOT renege
   . . . .
   yield release,self,resource
else:
   ## process reneged before acquiring resource
   . . . . .
</pre>
<p>A call to the <tt class="docutils literal"><span class="pre">self.acquired(resource)</span></tt> method is mandatory after a
compound <tt class="docutils literal"><span class="pre">yield</span> <span class="pre">request</span></tt> statement.  It not only indicates whether or
not the process has acquired the resource, it also removes the
reneging process from the resource's <tt class="docutils literal"><span class="pre">waitQ</span></tt>.</p>
</div>
<div class="section">
<h3><a id="reneging-after-a-time-limit" name="reneging-after-a-time-limit">Reneging after a time limit</a></h3>
<p>To make a process give up (renege) after a certain time, use a
reneging clause of the following form:</p>
<blockquote>
<tt class="docutils literal"><span class="pre">yield</span> <span class="pre">(request,self,</span></tt><em>r [,P]</em><tt class="docutils literal"><span class="pre">),</span></tt><tt class="docutils literal"><span class="pre">(hold,self,</span></tt><em>waittime</em><tt class="docutils literal"><span class="pre">)</span></tt></blockquote>
<p>Here the process requests one unit of the resource <em>r</em> with optional
priority <em>P</em>. If a resource unit is available it takes it and continues
its PEM. Otherwise, as usual, it is passivated and inserted into <em>r</em>'s <tt class="docutils literal"><span class="pre">waitQ</span></tt>.</p>
<p>The process takes a unit if it becomes available before <em>waittime</em>
expires and continues executing its PEM. If, however, the process has
not acquired a unit before the <em>waittime</em> has expired it abandons the
request (reneges) and leaves the <tt class="docutils literal"><span class="pre">waitQ</span></tt>.</p>
<hr class="docutils" />
<p><strong>Example</strong>: part of a parking lot simulation:</p>
<pre class="literal-block">
. . . .
parking_lot=Resource(capacity=10)
patience=5   # wait no longer than &quot;patience&quot; time units
             # for a parking space
park_time=60 # park for &quot;park_time&quot; time units if get a parking space
. . . .
yield (request,self,parking_lot),(hold,self,patience)
if self.acquired(parking_lot):
   # park the car
   yield hold,self,park_time
   yield release,self,parking_lot
else:
   # patience exhausted, so give up
   print 'I'm not waiting any longer. I am going home now.'
</pre>
</div>
<hr class="docutils" />
<div class="section">
<h3><a id="reneging-when-an-event-has-happened" name="reneging-when-an-event-has-happened">Reneging when an event has happened</a></h3>
<p>To make a process renege at the occurrence of an event, use a reneging
clause having a pattern like the one used for a <tt class="docutils literal"><span class="pre">yield</span> <span class="pre">waitevent</span></tt>
statement, namely <tt class="docutils literal"><span class="pre">waitevent,self,</span></tt><em>events</em> (see <a class="reference" href="#yield-waitevent">yield waitevent</a>).
For example:</p>
<blockquote>
<tt class="docutils literal"><span class="pre">yield</span> <span class="pre">(request,self,</span></tt><em>r [,P]</em><tt class="docutils literal"><span class="pre">),</span></tt><tt class="docutils literal"><span class="pre">(waitevent,self,</span></tt><em>events</em><tt class="docutils literal"><span class="pre">)</span></tt></blockquote>
<p>Here the process requests one unit of the resource <em>r</em> with optional
priority <em>P</em>. If a resource unit is available it takes it and continues
its PEM. Otherwise, as usual, it is passivated and inserted into <em>r</em>'s <tt class="docutils literal"><span class="pre">waitQ</span></tt>.</p>
<p>The process takes a unit if it becomes available before any of the
<em>events</em> occur, and continues executing its PEM. If, however, any of
the SimEvents in <em>events</em> occur first, it abandons the
request (reneges) and leaves the <tt class="docutils literal"><span class="pre">waitQ</span></tt>. (Recall that <em>events</em> can be
either one event, a list, or a tuple of several SimEvents.)</p>
<hr class="docutils" />
<p><strong>Example</strong> Queuing for movie tickets (part):</p>
<pre class="literal-block">
. . . .
seats=Resource(capacity=100)
sold_out=SimEvent() # signals &quot;out of seats&quot;
too_late=SimEvent() # signals &quot;too late for this show&quot;
. . . .
# Leave the ticket counter queue when movie sold out
# or it is too late for the show
yield (request,self,seats),(waitevent,self,[sold_out,too_late])
if self.acquired(seats):
   # watch the movie
   yield hold,self,120
   yield release,self,seats
else:
   # did not get a seat
   print 'Who needs to see this silly movie anyhow?'
</pre>
</div>
<hr class="docutils" />
<div class="section">
<h3><a id="exiting-conventions-and-preemptive-queues" name="exiting-conventions-and-preemptive-queues">Exiting conventions and preemptive queues</a></h3>
<p>Many discrete event simulations (including SimPy) adopt the normal
&quot;exiting convention&quot;, according to which processes that have once
started using a Resource unit stay in some Resource queue until their
<tt class="docutils literal"><span class="pre">hold</span></tt> time has completed. This is of course automatically the case
for FIFO and non-preemptable <tt class="docutils literal"><span class="pre">PriorityQ</span></tt> disciplines. The point is
that the exiting convention is also applied in the <tt class="docutils literal"><span class="pre">preemptable</span></tt> queue
discipline case. Thus, processes remain in some Resource queue until
their <tt class="docutils literal"><span class="pre">hold</span></tt> time has completed, even if they are preempted by higher
priority processes.</p>
<p>Some real-world situations conform to this convention and some do
not. An example of one that does conform can be described as
follows. Suppose that at work you are assigned tasks of varying levels
of priority. You are to set aside lower priority tasks in order to
work on higher priority ones. But you are eventually to complete all
of your assigned tasks. So you are operating like a SimPy resource
that obeys a <tt class="docutils literal"><span class="pre">preemptable</span></tt> queue discipline and has one resource
unit. With this convention, half-finished low-priority tasks may be
postponed indefinitely if they are continually preempted by
higher-priority tasks.</p>
<p>An example that does not conform to the exiting convention can
be described as follows. Suppose again that you are assigned tasks of
varying levels of priority and are to set aside lower priority tasks
to work on higher priority ones. But you are instructed that any tasks
not completed within 24 hours after being assigned are to
be sent to another department for completion. Now, suppose
that you are assigned Task-A that has a priority level of 3 and will
take 10 hours to complete. After working on Task-A for an hour, you
are assigned Task-B, which has a priority level of 5 and will take 20
hours to complete. Then, at 11 hours, after working on Task-B for 10
hours, you are assigned Task-C, which has a priority level of 1 and
will take 4 hours to complete. (At this point Task-B needs 10 hours to
complete, Task-A needs 9 hours to complete, and Task-C needs 4 hours
to complete.) At 21 hours you complete Task-B and resume working on
Task-A, which at that point needs 9 hours to complete. At 24 hours
Task-A still needs another 6 hours to complete, but it has reached the
24-hour deadline and so is sent to another department for
completion. At the same time, Task-C has been in the waitQ for 13
hours, so you take it up and complete it at hour 28. This queue
discipline does not conform to the exiting convention, for under that
convention at 24 hours you would continue work on Task-A,
complete it at hour 30, and then start on Task-C.</p>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id34" id="recording-resource-queue-lengths" name="recording-resource-queue-lengths">4.5&nbsp;&nbsp;&nbsp;Recording Resource queue lengths</a></h2>
<p>Many discrete event models are used mainly to explore the
statistical properties of the <tt class="docutils literal"><span class="pre">waitQ</span></tt> and <tt class="docutils literal"><span class="pre">activeQ</span></tt> associated with
some or all of their simulated resources. SimPy's support for this
includes the <a class="reference" href="#defining-tallys-and-monitors">Monitor</a> and the <a class="reference" href="#defining-tallys-and-monitors">Tally</a>. For more information on
these and other recording
methods, see the section on <a class="reference" href="#recording-simulation-results">Recording Simulation Results</a>.</p>
<p>If a Resource, <tt class="docutils literal"><span class="pre">r</span></tt>, is defined with <tt class="docutils literal"><span class="pre">monitored=True</span></tt> SimPy
automatically records the length of its associated <tt class="docutils literal"><span class="pre">waitQ</span></tt> and
<tt class="docutils literal"><span class="pre">activeQ</span></tt>. These records are kept in the recorder objects called
<tt class="docutils literal"><span class="pre">r.waitMon</span></tt> and <tt class="docutils literal"><span class="pre">r.actMon</span></tt>, respectively. This solves a problem,
particularly for the <tt class="docutils literal"><span class="pre">waitQ</span></tt> which cannot easily be recorded
externally to the resource.</p>
<p>The property <tt class="docutils literal"><span class="pre">monitorType</span></tt> indicates which variety of recorder is to
be used, either <a class="reference" href="#defining-tallys-and-monitors">Monitor</a> or <a class="reference" href="#defining-tallys-and-monitors">Tally</a>. The default is <tt class="docutils literal"><span class="pre">Monitor</span></tt>. If
this is chosen, complete time series for both queue lengths are
maintained and can be used for advanced post-simulation statistical
analyses as well as for displaying summary statistics (such as
averages, standard deviations, and histograms). If <tt class="docutils literal"><span class="pre">Tally</span></tt> is chosen
summary statistics can be displayed, but complete time series
cannot. For more information on these and SimPy's other recording
methods, see the section on <a class="reference" href="#recording-simulation-results">Recording Simulation Results</a>.</p>
<hr class="docutils" />
<p><strong>Example</strong> The following program uses a <tt class="docutils literal"><span class="pre">Monitor</span></tt> to record the
<tt class="docutils literal"><span class="pre">server</span></tt> resource's queues.  After the simulation ends, it displays
some summary statistics for each queue, and then their complete time
series:</p>
<pre class="literal-block">
from SimPy.Simulation import *
from math import sqrt

class Client(Process):
    inClients=[]
    outClients=[]

    def __init__(self,name):
       Process.__init__(self,name)

    def getserved(self,servtime,myServer):
        print self.name, 'requests 1 unit at t =',now()
        yield request, self, myServer
        yield hold, self, servtime
        yield release, self, myServer
        print self.name,'done at t =',now()

initialize()

server=Resource(capacity=1,monitored=True,monitorType=Monitor)

c1=Client(name='c1') ; c2=Client(name='c2')
c3=Client(name='c3') ; c4=Client(name='c4')

activate(c1,c1.getserved(servtime=100,myServer=server))
activate(c2,c2.getserved(servtime=100,myServer=server))
activate(c3,c3.getserved(servtime=100,myServer=server))
activate(c4,c4.getserved(servtime=100,myServer=server))

simulate(until=500)

print
print '(TimeAverage no. waiting:',server.waitMon.timeAverage()
print '(Number) Average no. waiting:',server.waitMon.mean()
print '(Number) Var of no. waiting:',server.waitMon.var()
print '(Number) SD of no. waiting:',sqrt(server.waitMon.var())
print '(TimeAverage no. in service:',server.actMon.timeAverage()
print '(Number) Average no. in service:',server.actMon.mean()
print '(Number) Var of no. in service:',server.actMon.var()
print '(Number) SD of no. in service:',sqrt(server.actMon.var())
print '='*40
print 'Time history for the &quot;server&quot; waitQ:'
print '[time, waitQ]'
for item in server.waitMon:
    print item
print '='*40
print 'Time history for the &quot;server&quot; activeQ:'
print '[time, activeQ]'
for item in server.actMon:
    print item

</pre>
<p>The output from this program is:</p>
<pre class="literal-block">
c1 requests 1 unit at t = 0
c2 requests 1 unit at t = 0
c3 requests 1 unit at t = 0
c4 requests 1 unit at t = 0
c1 done at t = 100
c2 done at t = 200
c3 done at t = 300
c4 done at t = 400

(Time) Average no. waiting: 1.5
(Number) Average no. waiting: 1.5
(Number) Var of no. waiting: 0.916666666667
(Number) SD of no. waiting: 0.957427107756
(Time) Average no. in service: 1.0
(Number) Average no. in service: 0.5
(Number) Var of no. in service: 0.25
(Number) SD of no. in service: 0.5
========================================
Time history for the 'server' waitQ:
[time, waitQ]
[0, 1]
[0, 2]
[0, 3]
[100, 2]
[200, 1]
[300, 0]
========================================
Time history for the 'server' activeQ:
[time, activeQ]
[0, 1]
[100, 0]
[100, 1]
[200, 0]
[200, 1]
[300, 0]
[300, 1]
[400, 0]
</pre>
<p>This output illustrates the difference between the <em>(Time) Average</em>
and the <em>number statistics</em>. Here process <tt class="docutils literal"><span class="pre">c1</span></tt> was in the <tt class="docutils literal"><span class="pre">waitQ</span></tt>
for zero time units, process <tt class="docutils literal"><span class="pre">c2</span></tt> for 100 time units, and so
forth. The total wait time accumulated by all four processes during
the entire simulation run, which ended at time 400, amounts to 0 + 100
+ 200 + 300 = 600 time units. Dividing the 600 accumulated time units
by the simulation run time of 400 gives 1.5 for the <em>(Time) Average</em>
number of processes in the <tt class="docutils literal"><span class="pre">waitQ</span></tt>. It is the time-weighted average
length of the <tt class="docutils literal"><span class="pre">waitQ</span></tt>, but is almost always called simply the average
length of the <tt class="docutils literal"><span class="pre">waitQ</span></tt> or the average number of items waiting for a
resource.</p>
<p>It is also the expected number of processes you would find in the
<tt class="docutils literal"><span class="pre">waitQ</span></tt> if you took a snapshot of it at a random time during the
simulation. The <tt class="docutils literal"><span class="pre">activeQ</span></tt>'s time average computation is similar,
although in this example the resource is held by some process
throughout the simulation. Even though the number in the <tt class="docutils literal"><span class="pre">activeQ</span></tt>
momentarily drops to zero as one process releases the resource and
immediately rises to one as the next process acquires it, that occurs
instantaneously and so contributes nothing to the <em>(Time) Average</em>
computation.</p>
<hr class="docutils" />
<p><em>Number statistics</em> such as the Average, Variance, and SD are computed
differently. At time zero the number of processes in the <tt class="docutils literal"><span class="pre">waitQ</span></tt>
starts at 1, then rises to 2, and then to 3. At time 100 it drops back
to two processes, and so forth. The average and standard deviation of
the six values [1, 2, 3, 2, 1, 0] is 1.5 and 0.9574...,
respectively. Number statistics for the <tt class="docutils literal"><span class="pre">activeQ</span></tt> are computed using
the eight values [1, 0, 1, 0, 1, 0, 1, 0] and are as shown in the
output.</p>
<p>When the <tt class="docutils literal"><span class="pre">monitorType</span></tt> is changed to <tt class="docutils literal"><span class="pre">Tally</span></tt>, all the output up to
and including the lines:</p>
<pre class="literal-block">
Time history for the 'server' waitQ:
[time, waitQ]
</pre>
<p>is displayed. Then the output concludes with an error message
indicating a problem with the reference to <tt class="docutils literal"><span class="pre">server.waitMon</span></tt>. Of
course, this is because <tt class="docutils literal"><span class="pre">Tally</span></tt> does not generate complete time
series.</p>
<p>[Return to <a class="reference" href="#contents">Top</a> ]</p>
<!-- ========================================================================== -->
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id35" id="levels" name="levels">5&nbsp;&nbsp;&nbsp;Levels</a></h1>
<p>The three resource facilities provided by the SimPy system are
<a class="reference" href="#resources">Resources</a>, <a class="reference" href="#levels">Levels</a> and <a class="reference" href="#stores">Stores</a>. Each models a congestion point where
process objects may have to queue up to obtain resources. This section
describes the Level type of resource facility.</p>
<p>Levels model the production and consumption of a homogeneous
undifferentiated &quot;material.&quot; Thus, the currently-available amount of
material in a Level resource facility can be fully described by a
scalar (real or integer). Process objects may increase or decrease the
currently-available amount of material in a Level facility.</p>
<p>For example, a gasoline station stores gas (petrol) in large
tanks. Tankers increase, and refueled cars decrease, the amount of gas
in the station's storage tanks. Both getting amounts and putting
amounts may be subjected to <a class="reference" href="#reneging-leaving-a-queue-before-acquiring-a-resource">reneging</a> like requesting amounts from a
Resource.</p>
<div class="section">
<h2><a class="toc-backref" href="#id36" id="defining-a-level" name="defining-a-level">5.1&nbsp;&nbsp;&nbsp;Defining a Level</a></h2>
<p>You define the Level resource facility <em>lev</em> by a statement like this:</p>
<pre class="literal-block">
lev = Level(name='a_level', unitName='units',
            capacity='unbounded', initialBuffered=0,
            putQType=FIFO, getQType=FIFO,
            monitored=False, monitorType=Monitor)
</pre>
<p>where</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">name</span></tt> (string type) is a descriptive name for the Level object <em>lev</em> is
known (e.g., <tt class="docutils literal"><span class="pre">'inventory'</span></tt>).</li>
<li><tt class="docutils literal"><span class="pre">unitName</span></tt> (string type) is a descriptive name for the units in which the
amount of material in <em>lev</em> is measured (e.g., <tt class="docutils literal"><span class="pre">'kilograms'</span></tt>).</li>
<li><tt class="docutils literal"><span class="pre">capacity</span></tt> (positive real or integer) is the capacity of the Level
object <em>lev</em>.  The default value is set to <tt class="docutils literal"><span class="pre">'unbounded'</span></tt> which is
interpreted as <tt class="docutils literal"><span class="pre">sys.maxint</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">initialBuffered</span></tt> (positive real or integer) is the initial amount of
material in the Level object <em>lev</em>.</li>
<li><tt class="docutils literal"><span class="pre">putQType</span></tt> (<tt class="docutils literal"><span class="pre">FIFO</span></tt> or <tt class="docutils literal"><span class="pre">PriorityQ</span></tt>) is the (producer) queue
discipline.</li>
<li><tt class="docutils literal"><span class="pre">getQType</span></tt> (<tt class="docutils literal"><span class="pre">FIFO</span></tt> or <tt class="docutils literal"><span class="pre">PriorityQ</span></tt>) is the (consumer) queue
discipline.</li>
<li><tt class="docutils literal"><span class="pre">monitored</span></tt> (boolean) specifies whether the queues and the amount
of material in <em>lev</em> will be recorded.</li>
<li><tt class="docutils literal"><span class="pre">monitorType</span></tt> (<tt class="docutils literal"><span class="pre">Monitor</span></tt> or <tt class="docutils literal"><span class="pre">Tally</span></tt>) specifies which type of
<a class="reference" href="#recording-simulation-results">Recorder</a> to use. Defaults to <tt class="docutils literal"><span class="pre">Monitor</span></tt>.</li>
</ul>
</blockquote>
<p>Every Level resource object, such as <tt class="docutils literal"><span class="pre">lev</span></tt>, also has the following
additional attributes:</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">lev.amount</span></tt> is the amount currently held in <em>lev</em>.</li>
<li><tt class="docutils literal"><span class="pre">lev.putQ</span></tt> is the queue of processes waiting to add amounts to <em>lev</em>,
so <tt class="docutils literal"><span class="pre">len(lev.putQ)</span></tt> is the number of processes waiting to add
amounts.</li>
<li><tt class="docutils literal"><span class="pre">lev.getQ</span></tt> is the queue of processes waiting to get amounts from
<em>lev</em>, so <tt class="docutils literal"><span class="pre">len(lev.getQ)</span></tt> is the number of processes waiting to
get amounts.</li>
<li><tt class="docutils literal"><span class="pre">lev.monitored</span></tt> is <tt class="docutils literal"><span class="pre">True</span></tt> if the queues are to be recorded. In
this case <tt class="docutils literal"><span class="pre">lev.putQMon</span></tt>, <tt class="docutils literal"><span class="pre">lev.getQMon</span></tt>, and <tt class="docutils literal"><span class="pre">lev.bufferMon</span></tt>
exist.</li>
<li><tt class="docutils literal"><span class="pre">lev.putQMon</span></tt> is a <a class="reference" href="#recording-simulation-results">Recorder</a> observing <tt class="docutils literal"><span class="pre">lev.putQ</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">lev.getQMon</span></tt> is a <a class="reference" href="#recording-simulation-results">Recorder</a> observing <tt class="docutils literal"><span class="pre">lev.getQ</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">lev.bufferMon</span></tt> is a <a class="reference" href="#recording-simulation-results">Recorder</a> observing <tt class="docutils literal"><span class="pre">lev.amount</span></tt>.</li>
</ul>
</blockquote>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id37" id="getting-amounts-from-a-level" name="getting-amounts-from-a-level">5.2&nbsp;&nbsp;&nbsp;Getting amounts from a Level</a></h2>
<p>Processes can request amounts from a Level and the same or other
processes can offer amounts to it.</p>
<p>A process, the <em>requester</em>, can request an amount <em>ask</em> from the
Level resource object <em>lev</em> by a <tt class="docutils literal"><span class="pre">yield</span> <span class="pre">get</span></tt> statement.:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">yield</span> <span class="pre">get,self,</span></tt><em>lev,ask[,P]</em></li>
</ul>
<p>Here <em>ask</em> must be a positive real or integer (the amount) and <em>P</em> is
an optional priority value (real or integer). If <em>lev</em> does not hold
enough to satisfy the request (that is, <em>ask &gt; lev</em><tt class="docutils literal"><span class="pre">.amount</span></tt>) the
requesting process is passivated and queued (in <em>lev</em><tt class="docutils literal"><span class="pre">.getQ</span></tt>) in order
of its priority. Subject to the priority order, it will be reactivated
when there is enough to satisfy the request.</p>
<p><tt class="docutils literal"><span class="pre">self.got</span></tt> holds the amount actually received by the requester.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id38" id="putting-amounts-into-a-level" name="putting-amounts-into-a-level">5.3&nbsp;&nbsp;&nbsp;Putting amounts into  a Level</a></h2>
<p>A process, the <em>offeror</em>, which is usually but not necessarily
different from the <em>requester</em>, can offer an amount <em>give</em> to a Level,
<em>lev</em>, by a <tt class="docutils literal"><span class="pre">yield</span> <span class="pre">put</span></tt> statement:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">yield</span> <span class="pre">put,self,</span></tt><em>lev,give[,P]</em></li>
</ul>
<p>Here <em>give</em> must be a positive real or integer, and <em>P</em> is an optional
priority value (real or integer). If the amount offered would lead to
an overflow (that is, <em>lev.</em><tt class="docutils literal"><span class="pre">amount</span></tt> + <em>give &gt; lev.</em><tt class="docutils literal"><span class="pre">capacity</span></tt>)  the offering process is passivated and queued (in
<tt class="docutils literal"><span class="pre">lev.putQ</span></tt>). Subject to the priority order, it will be reactivated
when there is enough space to hold the amount offered.</p>
<p>The orderings of processes in a Level's <tt class="docutils literal"><span class="pre">getQ</span></tt> and <tt class="docutils literal"><span class="pre">putQ</span></tt> behave like
those described for the <tt class="docutils literal"><span class="pre">waitQ</span></tt> under <a class="reference" href="#resources">Resources</a>, except that they are
not preemptable.  Thus, priority values are ignored when the queue
type is FIFO. Otherwise higher priority values have higher priority,
etc.</p>
<hr class="docutils" />
<p><strong>Example</strong>. Suppose that a random demand on an inventory is made each
day.  Each requested amount is distributed normally with a mean of 1.2
units and a standard deviation of 0.2 units.  The inventory (modeled
as an object of the Level class) is refilled by 10 units at fixed
intervals of 10 days. There are no back-orders, but a accumulated sum
of the total stock-out quantities is to be maintained.  A trace is to
be printed out each day and whenever there is a stock-out:</p>
<pre class="literal-block">
from SimPy.Simulation import *
from random import normalvariate,seed

class Deliver(Process):
   def deliver(self):          # an &quot;offeror&quot; PEM
       while True:
           lead = 10.0         # time between refills
           delivery = 10.0     # amount in each refill
           yield put, self, stock, delivery
           print 'at %7.4f, add %7.4f units, now amount = %6.4f'\
               %(now(),delivery,stock.amount)
           yield hold, self, lead

class Demand(Process):
   stockout = 0.0              # initialize initial stockout amount
   def demand(self):           # a &quot;requester&quot; PEM
       day = 1.0               # set time-step to one day
       while True:
           yield hold, self, day
           dd = normalvariate(1.20, 0.20)  # today's random demand
           ds = dd - stock.amount
               # excess of demand over current stock amount
           if dd &gt; stock.amount:   # can't supply requested amount
               yield get, self, stock, stock.amount  
                   # supply all available amount
               self.stockout += ds         
                   # add unsupplied demand to self.stockout
               print 'day %7.4f, demand = %7.4f, \
                   shortfall = %7.4f' %(now(), dd, -ds)
           else:                   # can supply requested amount
               yield get, self, stock, dd
               print 'day %7.4f, supplied %7.4f, now amount = %6.4f'\
                   %(now(), dd, stock.amount)

stock = Level(monitored=True)  # 'unbounded' capacity and other defaults

seed(99999)
initialize()

offeror = Deliver()
activate (offeror, offeror.deliver())
requester = Demand()
activate (requester, requester.demand())

simulate (until=49.9)

result=(stock.bufferMon.mean(), requester.stockout)
print
print 'Summary of results through end of day %7.4f:' %(int(now()))
print 'average stock = %7.4f, cumulative stockout = %7.4f' %result

</pre>
<p>Here is the last ten day's output from one run of this program:</p>
<pre class="literal-block">
at 40.0000, add 10.0000 units, now amount = 10.0000
day 40.0000, supplied  0.7490, now amount = 9.2510
day 41.0000, supplied  1.1651, now amount = 8.0858
day 42.0000, supplied  1.1117, now amount = 6.9741
day 43.0000, supplied  1.1535, now amount = 5.8206
day 44.0000, supplied  0.9202, now amount = 4.9004
day 45.0000, supplied  0.8990, now amount = 4.0014
day 46.0000, supplied  1.1448, now amount = 2.8566
day 47.0000, supplied  1.7287, now amount = 1.1279
day 48.0000, supplied  0.9608, now amount = 0.1670
day 49.0000, demand =  0.9837, shortfall = -0.8167

Summary of results through end of day 49.0000:
average stock =  4.2720, cumulative stockout =  9.7484
</pre>
<hr class="docutils" />
<p>[Return to <a class="reference" href="#contents">Top</a> ]</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id39" id="reneging" name="reneging">5.4&nbsp;&nbsp;&nbsp;Reneging</a></h2>
<p>The <tt class="docutils literal"><span class="pre">yield</span> <span class="pre">put</span></tt> can be subject to <a class="reference" href="#reneging-leaving-a-queue-before-acquiring-a-resource">reneging</a> using one of the compound
statements:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">yield</span> <span class="pre">(put,self,</span></tt><em>lev,ask[,P]</em><tt class="docutils literal"><span class="pre">),</span></tt><tt class="docutils literal"><span class="pre">(hold,self,</span></tt><em>waittime</em><tt class="docutils literal"><span class="pre">)</span></tt></li>
</ul>
<p>where if the process does not acquire the amount before <em>waittime</em> is
elapsed, the offerer leaves the <tt class="docutils literal"><span class="pre">waitQ</span></tt> and its execution continues or</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">yield</span> <span class="pre">(put,self,</span></tt><em>lev,ask[,P]</em><tt class="docutils literal"><span class="pre">),</span></tt><tt class="docutils literal"><span class="pre">(waitevent,self,</span></tt><em>events</em><tt class="docutils literal"><span class="pre">)</span></tt></li>
</ul>
<p>where if one of the SimEvents in <em>events</em> occurs before enough becomes
available, the offerer leaves the <tt class="docutils literal"><span class="pre">waitQ</span></tt> and its execution
continues.</p>
<p>In either case if reneging has <em>not</em> occurred the quantity will have
been put into the Level and <tt class="docutils literal"><span class="pre">self.stored(</span></tt><em>lev</em><tt class="docutils literal"><span class="pre">)</span></tt> will be
<tt class="docutils literal"><span class="pre">True</span></tt>. This must be tested immediately after the <tt class="docutils literal"><span class="pre">yield</span></tt>:</p>
<pre class="literal-block">
yield (put,self,lev,ask[,P]),(&lt;reneging clause&gt;)
if self.stored(lev):
   ## process  did not renege
   . . . .
else:
   ## process reneged before being able to put into the resource
</pre>
<p>The <tt class="docutils literal"><span class="pre">yield</span> <span class="pre">get</span></tt> can also be subject to <a class="reference" href="#reneging-leaving-a-queue-before-acquiring-a-resource">reneging</a> using one of the compound
statements:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">yield</span> <span class="pre">(get,self,lev,ask[,P]),(hold,self,waittime)</span></tt></li>
</ul>
<p>where if the process does not acquire the amount before <em>waittime</em> is
elapsed, the offerer leaves the <tt class="docutils literal"><span class="pre">waitQ</span></tt> and its execution continues.</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">yield</span> <span class="pre">(get,self,lev,ask[,P]),(waitevent,self,events)</span></tt></li>
</ul>
<p>where if one of the SimEvents in <em>events</em> occurs before enough becomes
available, reneging occurs, the offerer leaves the <tt class="docutils literal"><span class="pre">waitQ</span></tt> and its execution
continues.</p>
<p>In either case if reneging has <em>not</em> occurred <tt class="docutils literal"><span class="pre">self.got</span> <span class="pre">==</span> <span class="pre">ask</span></tt> and
<tt class="docutils literal"><span class="pre">self.acquired(lev)</span></tt> will be <tt class="docutils literal"><span class="pre">True</span></tt>. <tt class="docutils literal"><span class="pre">self.acquired(lev)</span></tt> must be called
immediately after the <tt class="docutils literal"><span class="pre">yield</span></tt>:</p>
<pre class="literal-block">
yield (get,self,lev,ask[,P]),(&lt;reneging clause&gt;)
if self.acquired(lev):
   ## process  did not renege, self.got == ask
   . . . .
else:
   ## process reneged before being able to put into the resource
</pre>
<p>This test removes the reneging process from the <tt class="docutils literal"><span class="pre">getQ</span></tt>.</p>
<p>[Return to <a class="reference" href="#contents">Top</a> ]</p>
<!-- ================================================================= -->
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id40" id="stores" name="stores">6&nbsp;&nbsp;&nbsp;Stores</a></h1>
<p>The three resource facilities provided by the SimPy system are
<a class="reference" href="#resources">Resources</a>, <a class="reference" href="#levels">Levels</a> and <a class="reference" href="#stores">Stores</a>. Each models a congestion point where
process objects may have to queue up to obtain resources. This section
describes the Store type of resource facility.</p>
<p>Stores model the production and consumption of individual items of any
Python type.  Process objects can insert or remove specific items from
the list of items available in a Store.  For example, surgical
procedures (treated as process objects) require specific lists of
personnel and equipment that may be treated as the items available in
a Store type of resource facility such as a clinic or hospital. As the
items held in a Store may be of any Python type, they may in
particular be process objects, and this can be exploited to facilitate
modeling Master/Slave relationships. <em>putting</em> and <em>getting</em> may also
be subjected to reneging.</p>
<div class="section">
<h2><a class="toc-backref" href="#id41" id="defining-a-store" name="defining-a-store">6.1&nbsp;&nbsp;&nbsp;Defining a Store</a></h2>
<p>The Store object <tt class="docutils literal"><span class="pre">sObj</span></tt> is established by a statement
like the following:</p>
<pre class="literal-block">
sObj = Store(name='a_store',
             unitName='units',
             capacity='unbounded',
             initialBuffered=None,
             putQType=FIFO,
             getQType=FIFO,
             monitored=False,
             monitorType=Monitor)
</pre>
<p>where</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">name</span></tt> (string type) is a descriptive name for <em>sObj</em> (e.g.,
<tt class="docutils literal"><span class="pre">'Inventory'</span></tt>).</li>
<li><tt class="docutils literal"><span class="pre">unitName</span></tt> (string type) is a descriptive name for the items
in <em>sObj</em> (e.g., <tt class="docutils literal"><span class="pre">'widgets'</span></tt>).</li>
<li><tt class="docutils literal"><span class="pre">capacity</span></tt> (positive integer) is the maximum number of
individual items that can be held in <em>sObj</em>.
The default value is set to <tt class="docutils literal"><span class="pre">'unbounded'</span></tt> which is
interpreted as <tt class="docutils literal"><span class="pre">sys.maxint</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">initialBuffered</span></tt> (a list of individual items) is <em>sObj</em>'s initial content.</li>
<li><tt class="docutils literal"><span class="pre">putQType</span></tt> (<tt class="docutils literal"><span class="pre">FIFO</span></tt> or <tt class="docutils literal"><span class="pre">PriorityQ</span></tt>) is the (producer) queue
discipline.</li>
<li><tt class="docutils literal"><span class="pre">getQType</span></tt> (<tt class="docutils literal"><span class="pre">FIFO</span></tt> or <tt class="docutils literal"><span class="pre">PriorityQ</span></tt>) is the (consumer) queue discipline.</li>
<li><tt class="docutils literal"><span class="pre">monitored</span></tt> (boolean) specifies whether <em>sObj</em>'s queues and contents
are to be recorded.</li>
<li><tt class="docutils literal"><span class="pre">monitorType</span></tt> (<tt class="docutils literal"><span class="pre">Monitor</span></tt> or <tt class="docutils literal"><span class="pre">Tally</span></tt>) specifies the type of <a class="reference" href="#recording-simulation-results">Recorder</a>
to be used. Defaults to <tt class="docutils literal"><span class="pre">Monitor</span></tt>.</li>
</ul>
</blockquote>
<p>The Store object <em>sObj</em> also has the following additional attributes:</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">sObj.theBuffer</span></tt> is a queue (list) of the individual items in <em>sObj</em>.
This list is in FIFO order unless the user stores them in a particular
order (see <a class="reference" href="#storing-objects-in-an-order">Storing objects in an order</a> , below). It is
read-only and not directly changeable by the user.</li>
<li><tt class="docutils literal"><span class="pre">sObj.nrBuffered</span></tt> is the current number of objects in <em>sObj</em>.
This is read-only and not directly changeable by the user.</li>
<li><tt class="docutils literal"><span class="pre">sObj.putQ</span></tt> is the queue of processes waiting to add items to <em>sObj</em>,
so that <tt class="docutils literal"><span class="pre">len(sObj.putQ)</span></tt> is the number of processes waiting to add items.</li>
<li><tt class="docutils literal"><span class="pre">sObj.getQ</span></tt> is the queue of processes waiting to get items from
<em>sObj</em>, so that <tt class="docutils literal"><span class="pre">len(sObj.getQ)</span></tt> is the number of processes waiting to
get items.</li>
<li>If <tt class="docutils literal"><span class="pre">sObj.monitored</span></tt> is <tt class="docutils literal"><span class="pre">True</span></tt> then the queues are to be recorded.
In this case <tt class="docutils literal"><span class="pre">sObj.putQMon</span></tt>,
<tt class="docutils literal"><span class="pre">sObj.getQMon</span></tt>, and <tt class="docutils literal"><span class="pre">sObj.bufferMon</span></tt> exist.</li>
<li><tt class="docutils literal"><span class="pre">sObj.putQMon</span></tt> is a <a class="reference" href="#recording-simulation-results">Recorder</a> observing <tt class="docutils literal"><span class="pre">sObj.putQ</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">sObj.getQMon</span></tt> is a <a class="reference" href="#recording-simulation-results">Recorder</a> observing <tt class="docutils literal"><span class="pre">sObj.getQ</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">sObj.bufferMon</span></tt>  is a <a class="reference" href="#recording-simulation-results">Recorder</a> observing <tt class="docutils literal"><span class="pre">sObj.nrBuffered</span></tt>.</li>
</ul>
</blockquote>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id42" id="putting-objects-into-a-store" name="putting-objects-into-a-store">6.2&nbsp;&nbsp;&nbsp;Putting objects into a Store</a></h2>
<p>Processes can request items from a Store and the same or
other processes can offer items to it. First look at the simpler of
these operations, the <tt class="docutils literal"><span class="pre">yield</span> <span class="pre">put</span></tt>.</p>
<p>A process, the <em>offeror</em>, which is usually but not necessarily
different from the <em>requester</em>, can offer a list of
items to <em>sObj</em> by a <tt class="docutils literal"><span class="pre">yield</span> <span class="pre">put</span></tt> statement:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">yield</span> <span class="pre">put,self,sObj,give[,P]</span></tt></li>
</ul>
<p>Here <tt class="docutils literal"><span class="pre">give</span></tt> is a list of any Python objects. If this statement would
lead to an overflow (that is, <tt class="docutils literal"><span class="pre">sObj.nrBuffered</span> <span class="pre">+</span> <span class="pre">len(give)</span> <span class="pre">&gt;</span>
<span class="pre">sObj.capacity</span></tt>) the putting process is passivated and queued (in
<tt class="docutils literal"><span class="pre">sObj.putQ</span></tt>) until there is sufficient room. <em>P</em> is an optional
priority value (real or integer).</p>
<p>The ordering of processes in a Store's putQ and getQ behave like those
described for the waitQ under <a class="reference" href="#resources">Resources</a> , except that they are not
preemptable.  Thus, priority values are ignored when the queue type is
FIFO.  Otherwise higher priority values indicate higher priority, etc.</p>
<p>The items in <em>sObj</em> are stored in the form of a queue called
<tt class="docutils literal"><span class="pre">sObj.theBuffer</span></tt>, which is in FIFO order unless the user has
arranged to sort them into a particular order (see <a class="reference" href="#storing-objects-in-an-order">Storing objects in
an order</a> below).</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id43" id="getting-objects-from-a-store" name="getting-objects-from-a-store">6.3&nbsp;&nbsp;&nbsp;Getting objects from  a Store</a></h2>
<p>There are two ways of getting objects from a Store. A process, the
<em>requester</em>, can either extract the first <tt class="docutils literal"><span class="pre">n</span></tt> objects from <em>sObj</em> or a list
of items chosen by a <em>filter function</em>.</p>
<p>Getting <em>n</em> items is achieved by the following statement:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">yield</span> <span class="pre">get,self,sObj,n</span> <span class="pre">[,P]</span></tt></li>
</ul>
<p>Here <em>n</em> must be a positive integer and <em>P</em> is an optional priority
value (real or integer).  If <em>sObj</em> does not currently hold enough
objects to satisfy this request (that is, <tt class="docutils literal"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">sObj.nrBuffered</span></tt>)
then the requesting process is passivated and queued (in
<tt class="docutils literal"><span class="pre">sObj.getQ</span></tt>). Subject to the priority ordering, it will be
reactivated when the request can be satisfied.</p>
<p>The retrieved objects are returned in the list attribute <tt class="docutils literal"><span class="pre">got</span></tt> of
the requesting process.</p>
<p><tt class="docutils literal"><span class="pre">yield</span> <span class="pre">get</span></tt> requests with a numerical parameter are honored in
priority/FIFO order. Thus, if
there are two processes in the Store's <tt class="docutils literal"><span class="pre">getQ</span></tt>, with the first requesting
two items and the second one, the second process gets the requested item
only after the first process has been given its two items.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id44" id="using-the-get-filter-function" name="using-the-get-filter-function">6.4&nbsp;&nbsp;&nbsp;Using the get filter function</a></h2>
<p>The second method is to get a list of items chosen by a <em>filter
function</em>, written by the user.</p>
<p>The command, using filter function <em>ffn</em> is as follows:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">yield</span> <span class="pre">get,self,sObj,ffn</span> <span class="pre">[,P]</span></tt></li>
</ul>
<p>The user provides a filter function that has a single list argument and
returns a list. The argument represents the buffer of the Store. The
function must search through the objects in the buffer and return a
sub-list of those that satisfy the requirement.</p>
<hr class="docutils" />
<p><strong>Example</strong> The filter function <tt class="docutils literal"><span class="pre">allweight</span></tt>, shown below, is an example
of such a filter. The argument, <tt class="docutils literal"><span class="pre">buff</span></tt>, will be automatically
replaced in the execution of
<tt class="docutils literal"><span class="pre">yield</span> <span class="pre">get,self,store,allweight</span></tt> by the buffer of the Store. In this
example the objects in the Store are assumed to have <tt class="docutils literal"><span class="pre">weight</span></tt>
attributes. The function <tt class="docutils literal"><span class="pre">allweight</span></tt> selects all those that have a
weight attribute over a value <tt class="docutils literal"><span class="pre">W</span></tt> and returns these as a list. The
list appears to the calling process as <tt class="docutils literal"><span class="pre">self.got</span></tt>:</p>
<pre class="literal-block">
def allweight(buff):
    &quot;&quot;&quot;filter: get all items with .weight &gt;=W from store&quot;&quot;&quot;
    result=[]
    for i in buff:
        if i.weight&gt;=W:
            result.append(i)
    return result
</pre>
<p>This might be used as follows:</p>
<pre class="literal-block">
yield get,self,sObj,allweight [,P]
</pre>
<p>The retrieved objects are returned in the list attribute <tt class="docutils literal"><span class="pre">got</span></tt> of
the requesting process.</p>
<hr class="docutils" />
<p><strong>Note:</strong> <em>``yield get``</em> requests with a filter function parameter
are not necessarily honored in priority/FIFO order, but rather
according to the filter function. An example: There are two processes
in the Store's <tt class="docutils literal"><span class="pre">getQ</span></tt>, with the first requesting an item with a
<em>weight</em> attribute less than 2 kilograms and the second one requesting
one with a <tt class="docutils literal"><span class="pre">weight</span></tt> attribute less than 3 kilograms. If there is an
item in the Store's buffer with a <tt class="docutils literal"><span class="pre">weight</span></tt> attribute between 2 and 3
and none with an attribute of less than 2, the second <tt class="docutils literal"><span class="pre">get</span></tt> requester
gets unblocked before the first one. Effectively, the SimPy run time
system runs through all processes in the <tt class="docutils literal"><span class="pre">getQ</span></tt> in sequence and
tests their filter functions as long as there are still items in the
Store's buffer.</p>
<hr class="docutils" />
<p><strong>Example</strong> The following program illustrates the use of a Store to
model the production and consumption of &quot;widgets&quot;. The widgets are
distinguished by their weight:</p>
<pre class="literal-block">
from SimPy.Simulation import *

class ProducerD(Process):
    def __init__(self):
        Process.__init__(self)
    def produce(self):           # the ProducerD PEM
        while True:
            yield put,self,buf,[Widget(9),Widget(7)]
            yield hold,self,10

class ConsumerD(Process):        
    def __init__(self):
        Process.__init__(self)
    def consume(self):           # the ConsumerD PEM
        while True:
            toGet=3
            yield get,self,buf,toGet
            assert len(self.got)==toGet
            print now(),'Get widget weights',\
                 [x.weight for x in self.got]
            yield hold,self,11

class Widget(Lister):
    def __init__(self,weight=0):
        self.weight=weight

widgbuf=[]
for i in range(10):
    widgbuf.append(Widget(5))

initialize()

buf=Store(capacity=11,initialBuffered=widgbuf,monitored=True)
for i in range(3):       # define and activate 3 producer objects
    p=ProducerD()
    activate(p,p.produce())
for i in range(3):       # define and activate 3 consumer objects
    c=ConsumerD()
    activate(c,c.consume())

simulate(until=50)

print 'LenBuffer:',buf.bufferMon     # length of buffer
print 'getQ:',buf.getQMon            # length of getQ
print 'putQ',buf.putQMon             # length of putQ

</pre>
<p>This program produces the following outputs
(some lines may be formatted differently):</p>
<pre class="literal-block">
0 Got widget weights [5, 5, 5]
0 Got widget weights [5, 5, 5]
0 Got widget weights [5, 5, 5]
11 Got widget weights [5, 9, 7]
11 Got widget weights [9, 7, 9]
11 Got widget weights [7, 9, 7]
22 Got widget weights [9, 7, 9]
22 Got widget weights [7, 9, 7]
22 Got widget weights [9, 7, 9]
33 Got widget weights [7, 9, 7]
33 Got widget weights [9, 7, 9]
40 Got widget weights [7, 9, 7]
44 Got widget weights [9, 7, 9]
50 Got widget weights [7, 9, 7]
LenBuffer: [[0, 10], [0, 7], [0, 9], [0, 11], [0, 8], [0, 10], [0, 7],
    [10, 9], [10, 11], [11, 8], [11, 10], [11, 7], [11, 4],
    [20, 6], [20, 8], [21, 10], [22, 7], [22, 4], [22, 1],
    [30, 3], [30, 5], [31, 7], [33, 4], [33, 1],
    [40, 3], [40, 0], [40, 2], [41, 4], [44, 1], [50, 3], [50, 0], [50, 2]]
getQ: [[0, 0], [33, 1], [40, 0], [44, 1], [50, 0]]
putQ [[0, 0], [0, 1], [0, 2], [0, 3], [0, 2], [0, 1], [0, 0], [10, 1],\
    [11, 0]]
</pre>
<hr class="docutils" />
<p>[Return to <a class="reference" href="#contents">Top</a> ]</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id45" id="id16" name="id16">6.5&nbsp;&nbsp;&nbsp;Reneging</a></h2>
<p>The <tt class="docutils literal"><span class="pre">yield</span> <span class="pre">put</span></tt> can be subject to <a class="reference" href="#reneging-leaving-a-queue-before-acquiring-a-resource">reneging</a> using one of the compound
statements:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">yield</span> <span class="pre">(put,self,sObj,give</span> <span class="pre">[,P]),(hold,self,waittime)</span></tt></li>
</ul>
<p>where if the process cannot put the list of objects in <em>give</em> before <em>waittime</em> is
elapsed, the offerer leaves the <tt class="docutils literal"><span class="pre">putQ</span></tt> and its execution continues or</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">yield</span> <span class="pre">(put,self,sObj,give</span> <span class="pre">[,P]),(waitevent,self,events)</span></tt></li>
</ul>
<p>where if one of the SimEvents in <em>events</em> occurs before it can put the
list of objects in <em>give</em> the offerer leaves the <tt class="docutils literal"><span class="pre">putQ</span></tt> and its
execution continues.</p>
<p>In either case if reneging has <em>not</em> occurred the list of objects in
<em>give</em> will have been put into the Store and <tt class="docutils literal"><span class="pre">self.stored(Sobj)</span></tt> will
be <tt class="docutils literal"><span class="pre">True</span></tt>.</p>
<p>The mandatory pattern for a <tt class="docutils literal"><span class="pre">put</span></tt> with reneging is:</p>
<pre class="literal-block">
yield (put,self,sObj,give [,P]),(&lt;reneging clause&gt;)
if self.stored(sObj):
   ## process  did not renege
   . . . .
else:
   ## process reneged before being able to put into the resource
</pre>
<p>This is so because <tt class="docutils literal"><span class="pre">self.stored(</span> <span class="pre">)</span></tt> not only tests for reneging, but
it also cleanly removes a reneging process from the <tt class="docutils literal"><span class="pre">putQ</span></tt>.</p>
<p>The <tt class="docutils literal"><span class="pre">yield</span> <span class="pre">get</span></tt> can be subject to similar <a class="reference" href="#reneging-leaving-a-queue-before-acquiring-a-resource">reneging</a> using one of the compound
statements:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">yield</span> <span class="pre">(get,self,sObj,n</span> <span class="pre">[,P]),(hold,self,waittime)</span></tt></li>
<li><tt class="docutils literal"><span class="pre">yield</span> <span class="pre">(get,self,sObj,ffn</span> <span class="pre">[,P]),(hold,self,waittime)</span></tt></li>
</ul>
<p>where if the process does not acquire the amount before <em>waittime</em> is
elapsed, the offerer leaves the <tt class="docutils literal"><span class="pre">waitQ</span></tt> and its execution continues.</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">yield</span> <span class="pre">(get,self,sObj,n</span> <span class="pre">[,P]),(waitevent,self,events)</span></tt></li>
<li><tt class="docutils literal"><span class="pre">yield</span> <span class="pre">(get,self,sObj,ffn</span> <span class="pre">[,P]),(waitevent,self,events)</span></tt></li>
</ul>
<p>where if one of the SimEvents in <em>events</em> occurs before enough becomes
available, reneging occurs, the offerer leaves the <tt class="docutils literal"><span class="pre">waitQ</span></tt> and its execution
continues.</p>
<p>In either case if reneging has <em>not</em> occurred <tt class="docutils literal"><span class="pre">self.got</span></tt> contains
the list of retrieved objects and <tt class="docutils literal"><span class="pre">self.acquired(Sobj)</span></tt> will be
<tt class="docutils literal"><span class="pre">True</span></tt>.</p>
<p>The mandatory pattern for a <tt class="docutils literal"><span class="pre">get</span></tt> with reneging is:</p>
<pre class="literal-block">
yield (get,self,lev,sObj,&lt;n or ffn&gt; [,P]),(&lt;reneging clause&gt;)
if self.acquired(sObj):
   ## process  did not renege,
   . . . .
else:
   ## process reneged before being able to put into the resource
</pre>
<p>This is so because <tt class="docutils literal"><span class="pre">self.acquired(</span> <span class="pre">)</span></tt> not only tests for reneging, but
it also cleanly removes a reneging process from the <tt class="docutils literal"><span class="pre">getQ</span></tt>.</p>
<p>[Return to <a class="reference" href="#contents">Top</a> ]</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id46" id="storing-objects-in-an-order" name="storing-objects-in-an-order">6.6&nbsp;&nbsp;&nbsp;Storing objects in an order</a></h2>
<p>The contents of a Store instance are listed in a queue.  By default,
this list is kept in FIFO order.  However, the list can be kept in a
user-defined order. You do this by defining a function for reordering
the list and adding it to the Store instance for which you want to
change the list order. Subsequently, the SimPy system will
automatically call that function after any addition (<tt class="docutils literal"><span class="pre">put</span></tt>) to the
queue.</p>
<hr class="docutils" />
<p><strong>Example</strong></p>
<pre class="literal-block">
class Parcel:
     def __init__(self,weight):
         self.weight=weight

lightFirst=Store()

def getLightFirst(self,par):
     &quot;&quot;&quot;Lighter parcels to front of queue&quot;&quot;&quot;
     tmplist=[(x.weight,x) for x in par]
     tmplist.sort()
     return [x for (key,x) in tmplist]

lightFirst.addSort(getLightFirst)
</pre>
<p>Now any <tt class="docutils literal"><span class="pre">yield</span> <span class="pre">get</span></tt> will get the lightest parcel in <tt class="docutils literal"><span class="pre">lightFirst</span></tt>'s
queue.</p>
<hr class="docutils" />
<p>The <tt class="docutils literal"><span class="pre">par</span></tt> parameter is automatically given the Store's buffer list as value
when the SimPy run time system calls the re-ordering function.</p>
<p><em>&lt;aStore&gt;.addSort(&lt;reorderFunction&gt;)</em> adds a re-order function to &lt;aStore&gt;.</p>
<p>Note that such function only changes the sorting order of the Store instance,
NOT of the Store class.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id47" id="master-slave-modeling-with-a-store" name="master-slave-modeling-with-a-store">6.7&nbsp;&nbsp;&nbsp;Master/Slave modeling with a Store</a></h2>
<p>The items in a <tt class="docutils literal"><span class="pre">Store</span></tt> can be of any Python type. In particular, they
may be SimPy processes. This can be used to model
a Master/Slave situation -- an asymmetrical cooperation between two or
more processes, with one process (the Master) being in charge of the
cooperation.</p>
<p>The consumer (Master) requests one or more Slaves to be added to the
Store's contents by the Producer (which may be the same process as the
Slave).  For Master/Slave cooperation, the Slave has to be passivated
(by a <tt class="docutils literal"><span class="pre">yield</span> <span class="pre">passivate</span></tt> or <tt class="docutils literal"><span class="pre">yield</span> <span class="pre">waitevent</span></tt> statement) after it is
<tt class="docutils literal"><span class="pre">put</span></tt> and reactivated when it is retrieved and finished with. As this
is NOT done automatically by the <tt class="docutils literal"><span class="pre">Store</span></tt>, the Master has to signal the
end of the cooperation. This Master/Slave pattern results in the slave process'
lifecycle having a hole between the slave process arrival and its departure
after having been served.</p>
<hr class="docutils" />
<p><strong>Example</strong> Cars arrive randomly at a car wash and add themselves to
the <tt class="docutils literal"><span class="pre">waitingCars</span></tt> queue. They wait (passively) for a <tt class="docutils literal"><span class="pre">doneSignal</span></tt>.
There are two <tt class="docutils literal"><span class="pre">Carwash</span></tt> washers. These <tt class="docutils literal"><span class="pre">get</span></tt> a car, if one is
available, wash it, and then send the <tt class="docutils literal"><span class="pre">doneSignal</span></tt> to reactivate
it. We elect to model the <tt class="docutils literal"><span class="pre">Carwash</span></tt> as Master and the <tt class="docutils literal"><span class="pre">Cars</span></tt> as
slaves.</p>
<p>Four cars are put into the <tt class="docutils literal"><span class="pre">waiting</span></tt> list and these make up the
initial set of cars waiting for service. Additional cars are generated
randomly by the <tt class="docutils literal"><span class="pre">CarGenerator</span></tt> process. Each car <tt class="docutils literal"><span class="pre">yield</span> <span class="pre">puts</span></tt> itself
onto the <tt class="docutils literal"><span class="pre">waitingCars</span></tt> <tt class="docutils literal"><span class="pre">Store</span></tt> and immediately passivates itself by
waiting for a <tt class="docutils literal"><span class="pre">doneSignal</span></tt> from a car washer. The car washers cycle
round <tt class="docutils literal"><span class="pre">getting</span></tt> the next car on the queue, washing it and then sending
a <tt class="docutils literal"><span class="pre">doneSignal</span></tt> to it when it has finished:</p>
<pre class="literal-block">
from SimPy.Simulation import *

&quot;&quot;&quot;Carwash is master
&quot;&quot;&quot;
class Carwash(Process):
    &quot;&quot;&quot;Carwash is master&quot;&quot;&quot;
    def __init__(self,name):
        Process.__init__(self,name)

    def lifecycle(self):
        while True:
            yield get,self,waitingCars,1
            carBeingWashed=self.got[0]
            yield hold,self,washtime
            carBeingWashed.doneSignal.signal(self.name)

class Car(Process):
    &quot;&quot;&quot;Car is slave&quot;&quot;&quot;
    def __init__(self,name):
        Process.__init__(self,name)
        self.doneSignal=SimEvent()
    def lifecycle(self):
        yield put,self,waitingCars,[self]
        yield waitevent,self,self.doneSignal
        whichWash=self.doneSignal.signalparam
        print '%s car %s done by %s' %(now(),self.name,whichWash)

class CarGenerator(Process):
    def generate(self):
        i=0
        while True:
            yield hold,self,2
            c=Car(i)
            activate(c,c.lifecycle())
            i+=1


washtime=5
initialize()
waiting=[]           # put four cars into the waiting list
for j in range(1,5):
    c=Car(name=-j)
    activate(c,c.lifecycle())
waitingCars=Store(capacity=40,initialBuffered=waiting)
for i in range(2):
    cw=Carwash('Carwash %s' %`i`)
    activate(cw,cw.lifecycle())
cg=CarGenerator()
activate(cg,cg.generate())
simulate(until=30)
print 'waitingCars',[x.name for x in waitingCars.theBuffer]

</pre>
<p>The output of this program, running to time 30, is:</p>
<pre class="literal-block">
5 car -1 done by Carwash 0
5 car -2 done by Carwash 1
10 car -3 done by Carwash 0
10 car -4 done by Carwash 1
15 car 0 done by Carwash 0
15 car 1 done by Carwash 1
20 car 2 done by Carwash 0
20 car 3 done by Carwash 1
25 car 4 done by Carwash 0
25 car 5 done by Carwash 1
30 car 6 done by Carwash 0
30 car 7 done by Carwash 1
waitingCars [10, 11, 12, 13, 14]
</pre>
<p>It is also possible to model this car wash with the cars as Master
and the <tt class="docutils literal"><span class="pre">Carwash</span></tt> as Slaves.</p>
<hr class="docutils" />
<p>[Return to <a class="reference" href="#contents">Top</a> ]</p>
<!-- ========================================================================== -->
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id48" id="random-number-generation" name="random-number-generation">7&nbsp;&nbsp;&nbsp;Random Number Generation</a></h1>
<p>Simulations usually need random numbers. As SimPy does not supply
random number generators of its own, users need to import them from
some other source.  Perhaps the most convenient source is the standard
<a class="reference" href="http://www.python.org/doc/current/lib/module-random.html">Python random module</a>.  It can generate random variates from the
following continuous distributions: uniform, beta, exponential, gamma,
normal, lognormal, weibull, and vonMises.  It can also generate random
variates from some discrete distributions. Consult the module's
documentation for details.  (Excellent brief descriptions of these
distributions, and many others, can be found in the <a class="reference" href="http://www.wikipedia.com/">Wikipedia</a>.)</p>
<p>Python's <tt class="docutils literal"><span class="pre">random</span></tt> module can be used in two ways: you can import the
methods directly or you can import the <tt class="docutils literal"><span class="pre">Random</span></tt> class and make your
own random objects. In the second method, each object gives a
different random number sequence, thus providing multiple random
streams as in Simscript and ModSim.</p>
<p>Here the first method is described (and minimally at that). A single
pseudo-random sequence is used for all calls. You <tt class="docutils literal"><span class="pre">import</span></tt> the
methods you need from the <tt class="docutils literal"><span class="pre">random</span></tt> module. For example:</p>
<pre class="literal-block">
from random import seed, random, expovariate, normalvariate
</pre>
<p>In simulation it is good practice to set the initial <tt class="docutils literal"><span class="pre">seed</span></tt> for the
pseudo-random sequence at the start of each run. Then you have control
over the random numbers used. Replications and comparisons are
easier and, together with variance reduction techniques, can provide more
accurate estimates. In the following code snippet we set the initial
seed to 333555.  <tt class="docutils literal"><span class="pre">X</span></tt> and <tt class="docutils literal"><span class="pre">Y</span></tt> are pseudo-random variates from the
two distributions. Both distributions have the same mean:</p>
<pre class="literal-block">
from random import seed, expovariate, normalvariate

seed(333555)
X = expovariate(0.1)
Y = normalvariate(10.0, 1.0)
</pre>
<p>[Return to <a class="reference" href="#contents">Top</a> ]</p>
<!-- ============================================================================ -->
</div>
<div class="section">
<h1><a class="toc-backref" href="#id49" id="recording-simulation-results" name="recording-simulation-results">8&nbsp;&nbsp;&nbsp;Recording Simulation Results</a></h1>
<p>The <tt class="docutils literal"><span class="pre">Tally</span></tt> and <tt class="docutils literal"><span class="pre">Monitor</span></tt> class objects  enable us to observe a single
variable of interest and to return a simple data summary either during
or at the completion of a simulation run.</p>
<p>Both use the <tt class="docutils literal"><span class="pre">observe</span></tt> method to record data on one variable. For
example we might use a Monitor object to record the waiting times for
a sequence of customers and another to record the total number of
customers in the shop. In a discrete-event system the number of
customers changes only at arrival or departure events and it is at
those events that the waiting times and number in the shop must be
observed. Monitors and Tallys provide elementary statistics useful
either alone or as the start of a more sophisticated statistical
analysis and have proved invaluable in many simulations.</p>
<p>A few more tools associated with recording results are:</p>
<ul class="simple">
<li>All Monitors are registered automatically in the global list
variable <tt class="docutils literal"><span class="pre">allMonitors</span></tt> and all Tallys in variable
<tt class="docutils literal"><span class="pre">allTallies</span></tt>. When a simulation is completed results can easily be
tabulated and summarized using these lists.</li>
<li>The function <tt class="docutils literal"><span class="pre">startCollection()</span></tt> can be called to initialize Monitors
and Tallys at a certain simulation time. This is helpful when a
simulation needs a 'warmup' period to achieve steady state before
measurements are started.</li>
</ul>
<div class="section">
<h2><a class="toc-backref" href="#id50" id="defining-tallys-and-monitors" name="defining-tallys-and-monitors">8.1&nbsp;&nbsp;&nbsp;Defining Tallys and Monitors</a></h2>
<p>The ''Tally'' class records enough information (such as sums and sums of
squares) while the simulation runs to return simple data summaries.
This has the advantage of speed and low memory use. Tallys can also
furnish data for a histogram. However, they do not preserve a
time-series usable in more advanced statistical analysis. When a Tally
is defined it is automatically added  to the global list <tt class="docutils literal"><span class="pre">allTallies</span></tt>.</p>
<p>To define a new Tally object:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">m=Tally(name='a_Tally',</span> <span class="pre">ylab='y',</span> <span class="pre">tlab='t')</span></tt></li>
</ul>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">name</span></tt> is a descriptive name for the tally object (default='<tt class="docutils literal"><span class="pre">a_Tally</span></tt>' ).</li>
<li><tt class="docutils literal"><span class="pre">ylab</span></tt> and <tt class="docutils literal"><span class="pre">tlab</span></tt> are descriptive labels used by the <a class="reference" href="SimPlotManual/ManualPlotting.html">SimPlot</a>
package when plotting graphs of the recorded data. They
default to <tt class="docutils literal"><span class="pre">'y'</span></tt> and <tt class="docutils literal"><span class="pre">'t'</span></tt>, respectively. (If a <a class="reference" href="#histograms">histogram</a> is
required the method <tt class="docutils literal"><span class="pre">setHistogram</span></tt> must be called before recording
starts).</li>
</ul>
</blockquote>
<p>The <tt class="docutils literal"><span class="pre">Monitor</span></tt> class preserves a complete time-series of the observed
data values, <em>y</em>, and their associated times, <em>t</em>. It calculates the
data summaries using these series only when they are needed. It is
slower and uses more memory than <tt class="docutils literal"><span class="pre">Tally</span></tt>. In long simulations its
memory demands may be a disadvantage. When a Monitor is defined it is
automatically added to the global list <tt class="docutils literal"><span class="pre">allMonitors</span></tt>.</p>
<p>To define a new Monitor object:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">m=Monitor(name='a_Monitor',</span> <span class="pre">ylab='y',</span> <span class="pre">tlab='t')</span></tt></li>
</ul>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">name</span></tt> is a descriptive name for the Monitor object (default='<tt class="docutils literal"><span class="pre">a_Monitor</span></tt>').</li>
<li><tt class="docutils literal"><span class="pre">ylab</span></tt> and <tt class="docutils literal"><span class="pre">tlab</span></tt> are descriptive labels used by the <a class="reference" href="SimPlotManual/ManualPlotting.html">SimPlot</a>
package when plotting graphs of the recorded data. They
default to <tt class="docutils literal"><span class="pre">'y'</span></tt> and <tt class="docutils literal"><span class="pre">'t'</span></tt>, respectively.
(A <a class="reference" href="#histograms">histogram</a> can be
requested at any time).</li>
</ul>
</blockquote>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id51" id="observing-data" name="observing-data">8.2&nbsp;&nbsp;&nbsp;Observing data</a></h2>
<p>Both Tallys and Monitors use the <tt class="docutils literal"><span class="pre">observe</span></tt> method to record data.
Here and in the next section, <em>r</em> is either a Tally or a Monitor object:</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">r.observe(y</span> <span class="pre">[,t])</span></tt> records the current value of the variable, <tt class="docutils literal"><span class="pre">y</span></tt>
and time <em>t</em> (or the current time, <tt class="docutils literal"><span class="pre">now(</span> <span class="pre">)</span></tt>, if <em>t</em> is missing). A
Monitor retains the two values as a sub-list <tt class="docutils literal"><span class="pre">[t,y]</span></tt>. A Tally
uses them to update the accumulated statistics.</p>
<p>To assure that time averages are calculated correctly <tt class="docutils literal"><span class="pre">observe</span></tt>
should be called immediately <em>after</em> a change in the variable. For
example, if we are using Monitor <em>r</em> to record the number <em>N</em>
of jobs in a system, the correct sequence of commands on an arrival
is:</p>
<pre class="literal-block">
N = N+1      # FIRST, increment the number of jobs
r.observe(N) # THEN observe the new value of N using r
</pre>
</li>
</ul>
<p>The recording of data can be <tt class="docutils literal"><span class="pre">reset</span></tt> to start at any time in the
simulation:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">r.reset([t])</span></tt> resets the observations. The recorded data is
re-initialized, and the observation starting time is set to <em>t</em>,
or to the current simulation time, <tt class="docutils literal"><span class="pre">now(</span> <span class="pre">)</span></tt>, if <em>t</em>
is missing.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id52" id="data-summaries" name="data-summaries">8.3&nbsp;&nbsp;&nbsp;Data summaries</a></h2>
<p>The following simple data summaries can be obtained from either
Monitors or Tallys at any time during or after the simulation run:</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">r.count(</span> <span class="pre">)</span></tt>, the current number of observations. (If <em>r</em> is a
Monitor this is the same as <tt class="docutils literal"><span class="pre">len(r)</span></tt>).</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">r.total(</span> <span class="pre">)</span></tt>, the sum of the <tt class="docutils literal"><span class="pre">y</span></tt> values</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">r.mean(</span> <span class="pre">)</span></tt>, the simple average of the observed <tt class="docutils literal"><span class="pre">y</span></tt> values,
ignoring the times at which they were made.  This is <tt class="docutils literal"><span class="pre">r.total(</span> <span class="pre">)/N</span></tt>
where <tt class="docutils literal"><span class="pre">N=r.count(</span> <span class="pre">)</span></tt>. (If there are no observations, the message:
&quot;SimPy: No observations for mean&quot; is printed). See
<a class="reference" href="#recording-resource-queue-lengths">Recording Resource queue lengths</a> for the difference between
the simple or numerical average and the time-average.</p>
<div align="center" class="figure" style="width: 400px">
<img alt="Standard mean value" src="images/Mon004.png" />
<p class="caption"><tt class="docutils literal"><span class="pre">r.mean</span></tt> is the simple average of the <tt class="docutils literal"><span class="pre">y</span></tt> values observed.</p>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">r.var(</span> <span class="pre">)</span></tt> the <em>sample</em> variance of the observations, ignoring the
times at which they were made. If an unbiased estimate of the
<em>population</em> variance is desired, the sample variance should be
multiplied by <em>n/(n-1)</em>, where <em>n = r.count( )</em>.  In either case the
standard deviation is, of course, the square-root of the variance
(If there are no observations, the message: &quot;SimPy: No observations
for sample variance&quot; is printed).</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">r.timeAverage([t])</span></tt> the time-weighted average of <tt class="docutils literal"><span class="pre">y</span></tt>,
calculated from time 0 (or the last time <tt class="docutils literal"><span class="pre">r.reset([t])</span></tt> was
called) to time <em>t</em> (or to the current simulation time, <tt class="docutils literal"><span class="pre">now(</span> <span class="pre">)</span></tt>,
if <em>t</em> is missing).  This is determined from the area under the
graph shown in the figure, divided by the total time of observation.
For accurate time-average results <tt class="docutils literal"><span class="pre">y</span></tt> most be piecewise constant
and <tt class="docutils literal"><span class="pre">observed</span></tt> just after each change in its value. (If there are
no observations, the message &quot;SimPy: No observations for
timeAverage&quot; is printed. If no time has elapsed, the message &quot;SimPy:
No elapsed time for timeAverage&quot; is printed).</p>
<div align="center" class="figure" style="width: 400px">
<img alt="Time Average" src="images/Mon005.png" />
<p class="caption"><tt class="docutils literal"><span class="pre">r.timeAverage(</span> <span class="pre">)</span></tt> is the time-weighted average of the observed
<tt class="docutils literal"><span class="pre">y</span></tt> values. Each <tt class="docutils literal"><span class="pre">y</span></tt> value is weighted by the time for which it
exists. The average is the area under the above curve divided by the total
time, <em>t</em>.</p>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">r.timeVariance([t])</span></tt> the time-weighted variance of the <tt class="docutils literal"><span class="pre">y</span></tt>
values calculated from time 0 (or the last time <tt class="docutils literal"><span class="pre">r.reset([t])</span></tt> was
called) to time <em>t</em> (or to the current simulation time, <tt class="docutils literal"><span class="pre">now()</span></tt>,
if <em>t</em> is missing).</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">r.__str__(</span> <span class="pre">)</span></tt> is a string that briefly describes the current state
of the monitor. This can be used in a print statement.</p>
</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id53" id="special-methods-for-monitor" name="special-methods-for-monitor">8.4&nbsp;&nbsp;&nbsp;Special methods for Monitor</a></h2>
<p>The <tt class="docutils literal"><span class="pre">Monitor</span></tt> variety of Recorder is a sub-class of <tt class="docutils literal"><span class="pre">List</span></tt>
and has a few extra methods:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">m[i]</span></tt> holds the observation <tt class="docutils literal"><span class="pre">i</span></tt> as a two-item list, <em>[ti, yi]</em></li>
<li><tt class="docutils literal"><span class="pre">m.yseries(</span> <span class="pre">)</span></tt> is a list of the recorded data values, <em>yi</em></li>
<li><tt class="docutils literal"><span class="pre">m.tseries(</span> <span class="pre">)</span></tt> is a list of the recorded times, <em>ti</em></li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id54" id="histograms" name="histograms">8.5&nbsp;&nbsp;&nbsp;Histograms</a></h2>
<p>A <tt class="docutils literal"><span class="pre">Histogram</span></tt> is a derived class of <tt class="docutils literal"><span class="pre">list</span></tt> that counts the
observations that fall into a number of specified ranges, called bins.
A histogram object can be displayed either by printing it out in text
form using <tt class="docutils literal"><span class="pre">printHistogram</span></tt> method or using the <tt class="docutils literal"><span class="pre">plotHistogram</span></tt> method in the
<a class="reference" href="SimPlotManual/ManualPlotting.html">SimPlot</a> package.</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">h</span> <span class="pre">=</span> <span class="pre">Histogram(low=&lt;float&gt;,high=&lt;float&gt;,nbins=&lt;integer&gt;)</span></tt> is a
histogram object that counts the
number of <tt class="docutils literal"><span class="pre">y</span></tt> values in each of its bins, based on the
recorded <tt class="docutils literal"><span class="pre">y</span></tt> values.</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">low</span></tt> is the nominal lowest value of the histogram (default=0.0)</li>
<li><tt class="docutils literal"><span class="pre">high</span></tt> is the nominal highest value of the histogram (default=100.0)</li>
<li><tt class="docutils literal"><span class="pre">nbins</span></tt> is the number of bins between <tt class="docutils literal"><span class="pre">low</span></tt> and <tt class="docutils literal"><span class="pre">high</span></tt> into which
the histogram is to be divided (default=10).
SimPy automatically constructs an additional two bins
to count the
number of <tt class="docutils literal"><span class="pre">y</span></tt> values <tt class="docutils literal"><span class="pre">under</span></tt> the <tt class="docutils literal"><span class="pre">low</span></tt> value and the number
<tt class="docutils literal"><span class="pre">over</span></tt> the <tt class="docutils literal"><span class="pre">high</span></tt> value. Thus, the total number of bins
actually used is <tt class="docutils literal"><span class="pre">nbins</span> <span class="pre">+</span> <span class="pre">2</span></tt>. The number of <tt class="docutils literal"><span class="pre">y</span></tt>
values in each of these bins is counted and assigned
to the appropriate bin.</li>
</ul>
<div align="center" class="figure" style="width: 500px">
<img alt="Histogram" src="images/Mon006.png" />
<p class="caption">A Histogram contains the number of observed <tt class="docutils literal"><span class="pre">y</span></tt> values falling
into each of its <tt class="docutils literal"><span class="pre">nbins+2</span></tt> bins.</p>
</div>
</li>
</ul>
<p>A Histogram, <em>h</em>, can be printed out in text form using</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">h.printHistogram(fmt=&quot;%s&quot;)</span></tt> prints out a histogram in a standard
format.<ul>
<li><tt class="docutils literal"><span class="pre">fmt</span></tt> is a python string format for the bin range values.</li>
</ul>
</li>
</ul>
<!-- THIS MUST BE CLARIFIED. hOW IS IT USED WITH MONITOR? -->
<hr class="docutils" />
<p><strong>Example</strong> Printing a histogram from a Tally:</p>
<pre class="literal-block">
from SimPy.Simulation import *
import random as r

print version

t=Tally(name=&quot;myTally&quot;,ylab=&quot;wait time (sec)&quot;)
t.setHistogram(low=0.0,high=1.0,nbins=10)
for i in range(100000):
    t.observe(y=r.random())
print t.printHistogram(fmt=&quot;%6.4f&quot;)
</pre>
<p>This gives a printed histogram like this:</p>
<pre class="literal-block">
Histogram for myTally:
Number of observations: 100000
          wait time (sec) &lt; 0.0000:      0 (cum:      0/  0.0%)
0.0000 &lt;= wait time (sec) &lt; 0.1000:   9983 (cum:   9983/ 10.0%)
0.1000 &lt;= wait time (sec) &lt; 0.2000:  10121 (cum:  20104/ 20.1%)
0.2000 &lt;= wait time (sec) &lt; 0.3000:   9800 (cum:  29904/ 29.9%)
0.3000 &lt;= wait time (sec) &lt; 0.4000:   9911 (cum:  39815/ 39.8%)
0.4000 &lt;= wait time (sec) &lt; 0.5000:   9996 (cum:  49811/ 49.8%)
0.5000 &lt;= wait time (sec) &lt; 0.6000:   9881 (cum:  59692/ 59.7%)
0.6000 &lt;= wait time (sec) &lt; 0.7000:  10144 (cum:  69836/ 69.8%)
0.7000 &lt;= wait time (sec) &lt; 0.8000:  10029 (cum:  79865/ 79.9%)
0.8000 &lt;= wait time (sec) &lt; 0.9000:  10088 (cum:  89953/ 90.0%)
0.9000 &lt;= wait time (sec) &lt; 1.0000:  10047 (cum: 100000/100.0%)
1.0000 &lt;= wait time (sec)         :      0 (cum: 100000/100.0%)
</pre>
<hr class="docutils" />
<p>Although both Tallys and Monitors can return a histogram of the data, they
furnish histogram data in different ways.</p>
<ul class="simple">
<li>The Tally object accumulates the histogram's bin counts as each
value is observed during the simulation run. Since none of the
individual values are preserved, the <tt class="docutils literal"><span class="pre">setHistogram</span></tt> method must be
called to provide a histogram object to hold the accumulated bin
counts before any values are actually observed.</li>
<li>The Monitor object stores all its data, so the accumulated bin
counts can be computed whenever they are desired. Thus, the
histogram need not be set up until it is needed and this can be done
after the data has been gathered.</li>
</ul>
<div class="section">
<h3><a id="setting-up-a-histogram-for-a-tally-object" name="setting-up-a-histogram-for-a-tally-object">Setting up a Histogram for a Tally object</a></h3>
<p>To establish a histogram for a Tally object, <tt class="docutils literal"><span class="pre">r</span></tt>, we call the
<tt class="docutils literal"><span class="pre">setHistogram</span></tt> method with appropriate arguments before we observe any
data, e.g.,</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">r.setHistogram(name</span> <span class="pre">=</span> <span class="pre">'',low=0.0,high=100.0,nbins=10)</span></tt></li>
</ul>
<p>As usual, <tt class="docutils literal"><span class="pre">name</span></tt> is a descriptive title for the histogram (defaults to blank).
Then, after <tt class="docutils literal"><span class="pre">observing</span></tt> the data:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">h=r.getHistogram(</span> <span class="pre">)</span></tt> returns a completed histogram using the
histogram parameters as set up.</li>
</ul>
<hr class="docutils" />
<p><strong>Example</strong> In the following example we establish a <tt class="docutils literal"><span class="pre">Tally</span></tt> recorder
to observe values of an exponential random variate. It uses a
histogram with 30 bins (plus the under- and over-count bins):</p>
<pre class="literal-block">
from SimPy.Simulation import *
from random import expovariate

r = Tally('Tally')                          # define a tally object, r
r.setHistogram(name='exponential',
               low=0.0,high=20.0,nbins=30)  # set before observations

for i in range(1000):    # make the observations
   y = expovariate(0.1)
   r.observe(y)

h = r.getHistogram()     # return the completed histogram
</pre>
</div>
<hr class="docutils" />
<div class="section">
<h3><a id="setting-up-a-histogram-for-a-monitor-object" name="setting-up-a-histogram-for-a-monitor-object">Setting up a Histogram for a Monitor object</a></h3>
<p>For Monitor objects, a histogram can be set up and returned in
a single call, e.g.,</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">h</span> <span class="pre">=</span> <span class="pre">r.histogram(low=0.0,high=100.0,nbins=10)</span></tt></li>
</ul>
<p>This  call is  equivalent to the following pair:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">r.setHistogram(name</span> <span class="pre">=</span> <span class="pre">'',low=0.0,high=100.0,nbins=10)</span></tt></li>
<li><tt class="docutils literal"><span class="pre">h</span> <span class="pre">=</span> <span class="pre">r.getHistogram(</span> <span class="pre">)</span></tt>, which returns the completed histogram.</li>
</ul>
<hr class="docutils" />
<p><strong>Example</strong> Here we establish a <tt class="docutils literal"><span class="pre">Monitor</span></tt> to observe values of an
exponential random variate. It uses a histogram with 30 bins (plus the
under- and over-count bins):</p>
<pre class="literal-block">
from SimPy.Simulation import *
from random import expovariate

m = Monitor()        # define the Monitor object, m

for i in range(1000):    # make the observations
   y = expovariate(0.1)
   m.observe(y)

   # set up and return the completed histogram
h = m.histogram(name='exponential',low=0.0, high=20, nbins=30)
</pre>
<hr class="docutils" />
<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
<!-- Note: The following methods of the Monitor class are
retained for backwards compatibility
but are not recommended. They may be removed in future releases of
SimPy.

* ``r.tally(y)`` records the current value of ``y`` and the current
  time, ``now( )``. (DO NOT USE)
* ``r.accum(y [,t])`` records the current value of ``y`` and time ``t``
  (the current time, ``now( )``, if ``t`` is missing). (DO NOT USE) -->
<p>[Return to <a class="reference" href="#contents">Top</a> ]</p>
<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
</div>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id55" id="other-links" name="other-links">9&nbsp;&nbsp;&nbsp;Other Links</a></h1>
<p>Several example <a class="reference" href="LISTOFMODELS.html">SimPy models</a> are included with the SimPy code distribution.</p>
<p>Klaus Muller and Tony Vignaux, <em>SimPy: Simulating Systems in Python</em>,
O'Reilly ONLamp.com, 2003-Feb-27,  <a class="reference" href="http://www.onlamp.com/pub/a/python/2003/02/27/simpy.html">http://www.onlamp.com/pub/a/python/2003/02/27/simpy.html</a></p>
<p>Norman Matloff, <em>Introduction to the SimPy Discrete-Event Simulation
Package</em>, U Cal: Davis, 2003,
<a class="reference" href="http://heather.cs.ucdavis.edu/~matloff/simpy.html">http://heather.cs.ucdavis.edu/~matloff/simpy.html</a></p>
<p>David Mertz, <em>Charming Python: SimPy simplifies complex models</em>, IBM
Developer Works, Dec 2002,
<a class="reference" href="http://www-106.ibm.com/developerworks/linux/library/l-simpy.html">http://www-106.ibm.com/developerworks/linux/library/l-simpy.html</a></p>
<p>[Return to <a class="reference" href="#contents">Top</a> ]</p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id56" id="acknowledgments" name="acknowledgments">10&nbsp;&nbsp;&nbsp;Acknowledgments</a></h1>
<p>We will be grateful for any further corrections or suggestions that
will improve it.</p>
<p>[Return to <a class="reference" href="#contents">Top</a> ]</p>
<!-- =================================================================== -->
</div>
<div class="section">
<h1><a class="toc-backref" href="#id57" id="appendices" name="appendices">11&nbsp;&nbsp;&nbsp;Appendices</a></h1>
<div class="section">
<h2><a class="toc-backref" href="#id58" id="a0-changes-from-the-previous-version-of-simpy" name="a0-changes-from-the-previous-version-of-simpy">11.1&nbsp;&nbsp;&nbsp;A0. Changes from the previous  version of SimPy</a></h2>
<p>SimPy 1.9 differs from version 1.8 in the following ways.  It requires
Python 2.3 or later. It fixes a few bugs and adds:</p>
<p>NEW APPENDIX NEEDED</p>
<!-- - a compound ``put`` and ``get`` for Levels_ and Stores_ like the compound
  ``get`` for Resources_.

- ``startCollection()`` to initialize Monitors_ and Tallys_ at a certain
  time.

- code to register all Monitors_ in variable ``allMonitors`` and all
  Tallys_ in variable ``allTallies``.

- a variable ``version`` which returns the SimPy version number and date. -->
<p>[Return to <a class="reference" href="#contents">Top</a> ]</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id59" id="a1-simpy-error-messages" name="a1-simpy-error-messages">11.2&nbsp;&nbsp;&nbsp;A1. SimPy Error Messages</a></h2>
<div class="section">
<h3><a id="advisory-messages" name="advisory-messages">Advisory messages</a></h3>
<p>These messages are returned by <tt class="docutils literal"><span class="pre">simulate(</span> <span class="pre">)</span></tt>, as in
<tt class="docutils literal"><span class="pre">message=simulate(until=123)</span></tt>.</p>
<p>Upon a normal end of a simulation, <tt class="docutils literal"><span class="pre">simulate(</span> <span class="pre">)</span></tt> returns the message:</p>
<ul class="simple">
<li><strong>SimPy: Normal exit</strong>. This means that no errors have occurred and
the simulation has run to the time specified by the <tt class="docutils literal"><span class="pre">until</span></tt> parameter.</li>
</ul>
<p>The following messages, returned by <tt class="docutils literal"><span class="pre">simulate(</span> <span class="pre">)</span></tt>, are produced at a premature
termination of the simulation but allow continuation of the program.</p>
<ul class="simple">
<li><strong>SimPy: No more events at time x</strong>. All processes were completed prior
to the <em>endtime</em> given in <em>simulate(until=endtime)</em>.</li>
<li><strong>SimPy: No activities scheduled</strong>. No activities were scheduled
when <em>simulate( )</em> was called.</li>
</ul>
</div>
<div class="section">
<h3><a id="fatal-error-messages" name="fatal-error-messages">Fatal error messages</a></h3>
<p>These messages are generated when SimPy-related fatal  exceptions occur.
They end the SimPy program. Fatal SimPy error messages are output to
<em>sysout</em>.</p>
<ul class="simple">
<li><strong>Fatal SimPy error: activating function which is not a generator (contains no 'yield')</strong>.
A process tried to (re)activate a function which is not a
SimPy process (=Python generator). SimPy processes must contain
at least one <em>yield . . .</em> statement.</li>
<li><strong>Fatal SimPy error: Simulation not initialized</strong>. The SimPy program
called <em>simulate( )</em> before calling <em>initialize( )</em>.</li>
<li><strong>SimPy: Attempt to schedule event in the past</strong>: A <em>yield hold</em> statement
has a negative delay time parameter.</li>
<li><strong>SimPy: initialBuffered exceeds capacity</strong>: Attempt to initialize a Store
or Level with more units in the buffer than its capacity allows.</li>
<li><strong>SimPy: initialBuffered param of Level negative: x</strong>: Attempt to
initialize a Level with a negative amount x in the buffer.</li>
<li><strong>SimPy: Level: wrong type of initialBuffered (parameter=x)</strong>: Attempt to
initialize a buffer with a non-numerical initial buffer content x.</li>
<li><strong>SimPy: Level: put parameter not a number</strong>: Attempt to add a
non-numerical amount to a Level's buffer.</li>
<li><strong>SimPy: Level: put parameter not positive number</strong>: Attempt to add
a negative number to a Level's amount.</li>
<li><strong>SimPy: Level: get parameter not positive number: x</strong>: Attempt to
get a negative amount x from a Level.</li>
<li><strong>SimPy: Store: initialBuffered not a list</strong>: Attempt to initialize
a Store with other than a list of items in the buffer.</li>
<li><strong>SimPy: Item to put missing in yield put stmt</strong>: A <em>yield put</em> was
malformed by not having a parameter for the item(s) to put into the
Store.</li>
<li><strong>SimPy: put parameter is not a list</strong>: <em>yield put</em> for a Store must
have a parameter which is a list of items to put into the buffer.</li>
<li><strong>SimPy: Store: get parameter not positive number: x</strong>: A <em>yield
get</em> for a Store had a negative value for the number to get from the
buffer.</li>
<li><strong>SimPy: Fatal error: illegal command: yield x</strong>: A <em>yield</em>
statement with an undefined command code (first parameter) x was
executed.</li>
</ul>
</div>
<div class="section">
<h3><a id="monitor-error-messages" name="monitor-error-messages">Monitor error messages</a></h3>
<ul class="simple">
<li><strong>SimPy: No observations for mean</strong>. No observations were made by the
monitor before attempting to calculate the mean.</li>
<li><strong>SimPy: No observations for sample variance</strong>. No observations were made by the
monitor before attempting to calculate the sample variance.</li>
<li><strong>SimPy: No observations for timeAverage</strong>, No observations
were made by the monitor before attempting to calculate the time-average.</li>
<li><strong>SimPy: No elapsed time for timeAverage</strong>. No simulation
time has elapsed before attempting to calculate the time-average.</li>
</ul>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id60" id="a2-simpy-process-states" name="a2-simpy-process-states">11.3&nbsp;&nbsp;&nbsp;A2. SimPy Process States</a></h2>
<p>From the viewpoint of the model builder a SimPy process, <em>p</em>,
can at any time be in one of the following states:</p>
<ul class="simple">
<li><strong>Active</strong>: Waiting for a scheduled event. This state simulates an
activity in the model.  Simulated time passes in this
state. The process state <em>p.active( )</em> returns <em>True</em>.</li>
<li><strong>Passive</strong>: Not active or terminated. Awaiting <em>(re-)activation</em> by
another process.  This state simulates a real world process which
has not finished and is waiting for some trigger to continue. Does
not change simulation time.  <em>p.passive( )</em> returns <em>True</em>.</li>
<li><strong>Terminated</strong>: The process has executed all its action statements.
If referenced, it serves as a data instance. <em>p.terminated( )</em>
returns <em>True</em></li>
</ul>
<p>Initially (upon creation of the Process instance), a process returns <em>passive</em>.</p>
<p>In addition, a SimPy process, <em>p</em>,  can be in the following (sub)states:</p>
<ul class="simple">
<li><strong>Interrupted</strong>: Active process has been interrupted by another
process. It can immediately respond to the interrupt. This
simulates an interruption of a simulated activity before its
scheduled completion time.  <em>p.interrupted( )</em> returns <em>True</em>.</li>
<li><strong>Queuing</strong>: Active process has requested a busy resource and is
waiting (passive) to be reactivated upon resource
availability. <em>p.queuing(a_resource)</em> returns <em>True</em>.</li>
</ul>
<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
</div>
<div class="section">
<h2><a class="toc-backref" href="#id61" id="a3-simplot-the-simpy-plotting-utility" name="a3-simplot-the-simpy-plotting-utility">11.4&nbsp;&nbsp;&nbsp;A3. SimPlot, The SimPy plotting utility</a></h2>
<p><a class="reference" href="SimPlotManual/ManualPlotting.html">SimPlot</a> provides an easy way to graph the results of simulation runs.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id62" id="a4-simgui-the-simpy-graphical-user-interface" name="a4-simgui-the-simpy-graphical-user-interface">11.5&nbsp;&nbsp;&nbsp;A4. SimGUI, The SimPy Graphical User Interface</a></h2>
<p><a class="reference" href="SimGUIManual/SimGUImanual.html">SimGUI</a>  provides a  way for users to interact with a SimPy program,
changing its parameters and examining the output.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id63" id="a5-simulationtrace-the-simpy-tracing-utility" name="a5-simulationtrace-the-simpy-tracing-utility">11.6&nbsp;&nbsp;&nbsp;A5. SimulationTrace, the SimPy tracing utility</a></h2>
<p><a class="reference" href="Tracing.html">SimulationTrace</a> has been developed to give users insight into the
dynamics of the execution of SimPy simulation programs. It can help
developers with testing and users with explaining SimPy models to themselves
and others (e.g., for documentation or teaching purposes).</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id64" id="a6-simulationstep-the-simpy-event-stepping-utility" name="a6-simulationstep-the-simpy-event-stepping-utility">11.7&nbsp;&nbsp;&nbsp;A6. SimulationStep, the SimPy event stepping utility</a></h2>
<p><a class="reference" href="SimStepManual/SimStepManual.html">SimulationStep</a> can assist with debugging models, interacting with them on
an event-by-event basis, getting event-by-event output from a model (e.g.
for plotting purposes), etc.</p>
<p>It caters for:</p>
<blockquote>
<ul class="simple">
<li>running a simulation model, while calling a user-defined procedure after every event,</li>
<li>running a simulation model one event at a time by repeated calls,</li>
<li>starting and stopping the event-stepping mode under program control.</li>
</ul>
</blockquote>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id65" id="a7-simulationrt-a-real-time-synchronizing-utility" name="a7-simulationrt-a-real-time-synchronizing-utility">11.8&nbsp;&nbsp;&nbsp;A7. SimulationRT, a real-time synchronizing utility</a></h2>
<p><a class="reference" href="SimRTManual.html">SimulationRT</a> allows synchronizing simulation time and real (wall-clock) time.
This capability can be used to implement, e.g., interactive game applications or
to demonstrate a model's execution in real time.</p>
<p>[Return to <a class="reference" href="#contents">Top</a> ]</p>
<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id66" id="glossary" name="glossary">12&nbsp;&nbsp;&nbsp;Glossary</a></h1>
<p>(Note: Terms in <em>italics</em> refer to other special terms.
Items in <tt class="docutils literal"><span class="pre">code</span> <span class="pre">font</span></tt> are code fragments or specific code names.):</p>
<dl class="docutils">
<dt>activeQ</dt>
<dd>A <em>Resource</em> object automatically creates and maintains its
own activeQ, the queue (list) of process objects that are
currently using one of the Resource's units. See
<a class="reference" href="#resources">Resources</a>. (See also the Glossary entry for <em>waitQ</em>.)</dd>
<dt>activate</dt>
<dd>Commands a <em>process object</em> to being executing its <em>PEM</em>.
See <a class="reference" href="#starting-and-stopping-simpy-process-objects">Starting and stopping SimPy process objects</a>.</dd>
<dt>Backus-Naur Form (BNF) notation</dt>
<dd><p class="first">This manual occasionally uses a modified Backus-Naur Form notation to
exhibit command syntax,
as in the description of the <em>activate</em> command:</p>
<pre class="literal-block">
**activate(p, p.PEM([args]) [,{at=t|delay=period}] [,prior=False])**
</pre>
<p class="last">In this notation, square brackets [ ] indicate items that are optional,
braces { } indicate items of which zero or more may be present,
and a vertical bar | indicates a choice between alternatives
(with none of them being a possibility).</p>
</dd>
<dt>cancel</dt>
<dd>Deletes all of a <em>process object's</em> scheduled future events.
See <a class="reference" href="#starting-and-stopping-simpy-process-objects">Starting and stopping SimPy process objects</a>.</dd>
<dt>entity</dt>
<dd>An alternative name for <em>process object</em>.</dd>
<dt>event</dt>
<dd>A SimEvent object. See <a class="reference" href="#advanced-synchronization-scheduling-capabilities">Advanced synchronization/scheduling capabilities</a>.</dd>
<dt>FIFO</dt>
<dd>An attribute of a resource object (i.e., a <a class="reference" href="#resources">Resource</a>, <a class="reference" href="#levels">Level</a>,
or <a class="reference" href="#stores">Store</a>)
indicating that an associated queue (e.g., the <em>ActiveQ</em>, <em>waitQ</em>,
<em>getQ</em>, or <em>putQ</em>) is to be
kept in FIFO order.
(See also the Glossary entries for <em>PriorityQ</em> and <em>qType</em>.)</dd>
<dt>getQ</dt>
<dd>The queue of processes waiting to take something from a
<a class="reference" href="#levels">Level</a> or <a class="reference" href="#stores">Store</a> resource. See also the Glossary entry for <em>putQ</em>.</dd>
<dt>interrupt</dt>
<dd>Requests a &quot;victim&quot; <em>process object</em> to interrupt (i.e., to immediately and
prematurely end) its current
<tt class="docutils literal"><span class="pre">yield</span> <span class="pre">hold,...</span></tt> command. (Note: A process object cannot interrupt itself.)
See <a class="reference" href="#asynchronous-interruptions">Asynchronous interruptions</a>.</dd>
<dt>Level</dt>
<dd>A particular type of <em>resource facility</em> that models the
production and consumption of a
homogeneous undifferentiated &quot;material.&quot; <em>Process objects</em> can increase or
decrease the amount of material in a Level resource facility. See <a class="reference" href="#levels">Levels</a>.</dd>
<dt>Monitor</dt>
<dd>A data recorder that compiles basic statistics as a function of time on
variables such
as waiting times and queue lengths. (Note: Monitors can also preserve complete
time-series
data for post-simulation analyses.) See <a class="reference" href="#recording-simulation-results">Recording Simulation Results</a>.</dd>
<dt>monitorType</dt>
<dd>The type of <a class="reference" href="#recording-simulation-results">Recorder</a> to be used for recording simulation results.
Usually this is either a <a class="reference" href="#defining-tallys-and-monitors">Monitor</a> or a <a class="reference" href="#defining-tallys-and-monitors">Tally</a>. (See also the
Glossary entry for <em>Recorder</em>.)</dd>
<dt>monitored</dt>
<dd>A (boolean) attribute of a <em>resource</em> object indicating whether to
keep a record
of its activity. See <a class="reference" href="#recording-simulation-results">Recorder</a>.</dd>
<dt>passivate</dt>
<dd>Halts (&quot;freezes&quot;) a <em>process object's</em> PEM. The process object  becomes
&quot;passive&quot;.
See <a class="reference" href="#starting-and-stopping-simpy-process-objects">Starting and stopping SimPy Process Objects</a>.</dd>
<dt>PEM</dt>
<dd>An abbreviation for <em>Process Execution Method</em>, q.v.</dd>
<dt>preempt</dt>
<dd>To force a <em>process</em> object currently using a <em>resource</em> unit
to release it and make it
available for use by another process object. See <a class="reference" href="#preemptive-requests-for-a-resource-unit">Preemptive requests for
a Resource unit</a>.</dd>
<dt>preemptable</dt>
<dd>A settable attribute of <em>Resource</em> objects. The Resource object's
units are preemptable if
<tt class="docutils literal"><span class="pre">preemptable==True</span></tt>, otherwise not. See <a class="reference" href="#preemptive-requests-for-a-resource-unit">Preemptive requests for a Resource
unit</a>.</dd>
<dt>priority</dt>
<dd>A non-negative integer or real value controlling the order of <em>process</em> objects
in a queue. Higher values represent higher priority. Higher priority process
objects are placed ahead of lower priority ones in the queue. See also
the Glossary entry for <em>FIFO</em>.</dd>
<dt>PriorityQ</dt>
<dd>An attribute of a resource object (i.e., a <a class="reference" href="#resources">Resource</a>, <a class="reference" href="#levels">Level</a>,
or <a class="reference" href="#stores">Store</a>)
indicating that an associated queue (e.g., the <em>ActiveQ</em>, <em>waitQ</em>,
<em>getQ</em>, or <em>putQ</em>) is to be
kept in order of <em>priority</em>.
(See also the Glossary entries for <em>FIFO</em>, <em>qType</em>.)</dd>
<dt>process</dt>
<dd>We usually call both process objects and their classes &quot;processes&quot;
(with a small &quot;p&quot;).
Thus, &quot;process&quot; may refer to a <em>Process class</em> or to
a <em>process object</em>, depending on context. To avoid ambiguity
or for added emphasis
we often explicitly state whether a class or an object is intended.</dd>
<dt>Process class</dt>
<dd>A class that inherits from SimPy's <tt class="docutils literal"><span class="pre">Process</span></tt> class and contains
at least one <em>Process Execution Method</em>.
Process classes may also contain other methods --
in particular they may contain an <tt class="docutils literal"><span class="pre">__init__</span></tt> method.
See <a class="reference" href="#processes">Processes</a>.</dd>
<dt>Process Execution Method</dt>
<dd>A <em>Process class</em> method that contains at least one <tt class="docutils literal"><span class="pre">yield</span> <span class="pre">...</span></tt>
statement. See <a class="reference" href="#defining-a-process">Defining a process</a>.</dd>
<dt>process object</dt>
<dd>An object created from (i.e., an instance of) a <em>Process class</em>.
See <a class="reference" href="#processes">Processes</a>.</dd>
<dt>putQ</dt>
<dd>The queue of processes waiting to add something to a <a class="reference" href="#levels">Level</a>
or <a class="reference" href="#stores">Store</a> resource. See also the Glossary entry for <em>getQ</em>.</dd>
<dt>reactivate</dt>
<dd>Reactivates (&quot;unfreezes&quot;) a passivated or a terminated <em>process object's</em> PEM.
The <em>process object</em> becomes &quot;active&quot;.  See <a class="reference" href="#starting-and-stopping-simpy-process-objects">Starting and stopping SimPy Process
Objects</a>.</dd>
<dt>Recorder</dt>
<dd>A device for recording simulation results. Unless otherwise specified, it
usually refers either to a <a class="reference" href="#defining-tallys-and-monitors">Monitor</a> or a <a class="reference" href="#defining-tallys-and-monitors">Tally</a>. However,
Recorders also include histograms and observers.
See <a class="reference" href="#recording-simulation-results">Recording Simulation Results</a>
for <em>Monitors</em>, <em>Tallys</em>, and the other devices for
recording simulation results.</dd>
<dt>renege</dt>
<dd>To leave a queue before acquiring a resource unit. See <a class="reference" href="#reneging-leaving-a-queue-before-acquiring-a-resource">Reneging -- leaving
a queue before acquiring a resource</a>.</dd>
<dt>resource</dt>
<dd>Same as &quot;resource facility.&quot;
A congestion point at which <em>process objects</em> may need to queue for access to
resources. The term &quot;resource&quot; (with a small &quot;r&quot;) is used as a generic term
for the individual resource facilities provided by SimPy (i.e.,
<a class="reference" href="#resources">Resources</a>, <a class="reference" href="#levels">Levels</a>, and <a class="reference" href="#stores">Stores</a>).</dd>
<dt>qType</dt>
<dd>An attribute of <em>resource</em> objects indicating whether an
associated queue is to be
kept in <em>FIFO</em> or <em>PriorityQ</em> order. See the Glossary entries
for <em>waitQ</em>, <em>ActiveQ</em>, <em>putQ</em>,and <em>getQ</em>.
See also the treatment of these queues in the sections on
the individual resources (i.e., <a class="reference" href="#resources">Resources</a>, <a class="reference" href="#levels">Levels</a>, and <a class="reference" href="#stores">Stores</a>).</dd>
<dt>Resource</dt>
<dd>A particular type of <em>resource facility</em> that possesses several
identical <em>resource units</em>.
A <em>process object</em> may acquire one (and only one) of the Resource's
resource units. See <a class="reference" href="#resources">Resources</a> .</dd>
<dt>Resource unit</dt>
<dd>One of the individual resources associated with a <em>Resource</em> type of
<em>resource facility</em>. See <a class="reference" href="#resources">Resources</a>.</dd>
<dt>SimEvent</dt>
<dd>The SimPy class for defining and creating SimEvent objects.
Occasionally designates a SimEvent
object when context makes that usage clear.
See <a class="reference" href="#advanced-synchronization-scheduling-capabilities">Advanced synchronization/scheduling capabilities</a>.</dd>
<dt>Store</dt>
<dd>A particular type of <em>resource facility</em> that models the
production and consumption of individual
items. <em>Process objects</em> can insert or remove items from the Store's list
of available items. See <a class="reference" href="#stores">Stores</a>.</dd>
<dt>Tally</dt>
<dd>A particular type of <em>Recorder</em> that compiles basic statistics as a
function of time on variables such
as waiting times and queue lengths. (Note: Tallys do not preserve complete
time-series data for post-simulation analyses.) See
<a class="reference" href="#recording-simulation-results">Recording Simulation Results</a>.
(See also the Glossary entry for <em>monitorType</em>.)</dd>
<dt>unit (of a Resource)</dt>
<dd>One of the individual resource capabilities provided by a <em>Resource</em>. See
<a class="reference" href="#resources">Resources</a>.</dd>
<dt>waitQ</dt>
<dd>A <em>Resource</em> object automatically creates and maintains its own <em>waitQ</em>,
the queue (list) of process objects that have requested but not yet
received one of the Resource's units. See <a class="reference" href="#resources">Resources</a>.
(See also the Glossary entry for <em>activeQ</em>.)</dd>
</dl>
<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
<!-- some useful stuff used above -->
<!-- .. image:: http://sourceforge.net/sflogo.php?group_id=62366&type=4
   :width: 125
   :height: 37
   :alt:  SourceForge Logo -->
<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
<!-- Local Variables:
mode: rst
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
End: -->
</div>
</div>
<div class="footer">
<hr class="footer" />
<a class="reference" href="Manual.txt">View document source</a>.
Generated on: 2008-03-12 04:31 UTC.
Generated by <a class="reference" href="http://docutils.sourceforge.net/">Docutils</a> from <a class="reference" href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> source.

</div>
</body>
</html>
